{
  
  
  
  
    "blogs-filtering-autobw": {
      "title": "Filtering Telemetry for RSVP-TE Auto-Bandwidth Demo",
      "content": "Telemetry recently took center stage at SDX Demo Friday with a new demo showcasing the RSVP-TE auto-bandwidth feature.  In the demo, the TE tunnel headend streamed data about the output bytes sent per tunnel and the resulting applied auto-bandwidth.  We streamed the data to SignalFX’s cloud monitoring system and were able to show nice visualizations of auto-bandwidth in action as well as some cool alerting capabilities.This demo gave us an opportunity to exercise the new filtering capability in IOS XR 6.0.1. The operational data for a TE Tunnel headend is contained in the native path RootOper.MPLS_TE.P2P_P2MPTunnel.TunnelHead({‘TunnelName’# ‘tunnel-te10’}). Streaming this path would result in over 600 lines of output for a single tunnel, with multiple layers of hierarchy.  To filter that data down to a single value, you can use a IncludeField in the policy file as follows#{   ~Name~#~RSVPTEPolicy~,   ~Metadata~#{      ~Version~#1,      ~Description~#~This policy collects auto bw stats~,      ~Comment~#~This is the first draft~   },   ~CollectionGroups~#{      ~FirstGroup~#{         ~Period~#10,         ~Paths~#{            ~RootOper.MPLS_TE.P2P_P2MPTunnel.TunnelHead({'TunnelName'# 'tunnel-te10'})~#{               ~IncludeFields~#[                  {                     ~P2PInfo~#[                        {                           ~AutoBandwidthOper~#[                              ~LastBandwidthApplied~                           ]                        }                     ]                  }               ]            }         }      }   }}With this IncludeFilter, the telemetry engine will only encode the latest applied auto-bandwidth value for the specified TE tunnel (which is nested two levels down from the top level of the path).Filtering on the router is a big win from a performance perspective.  Obviously, the collector (SignalFX in this case) benefits if it has to process less data.  But the router benefits, too.  Internally, the telemetry process still retrieves the entire “bag” of data (i.e. the 600 lines of stuff) to take advantage of bulk retrieval optimizations.  That’s pretty much a fixed cost in terms of CPU utilization.  The good news is that filtering optimizations allow the encoding process to completely skip over everything except the fields you want.  Skipping is much more efficient than processing, which decreases the demand on the CPU.  Moreover, the resulting data stream is much smaller.  Since a large proportion of the telemetry CPU usage is for packet IO, a smaller data stream again means less CPU utilization.  So for maximum efficiency, filter when you can!",
      "url": "/blogs/filtering_autobw",
      "author": "Shelly Cadora",
      "tags": "iosxr, telemetry"
    }
    
    ,
  
  
  
    "blogs-2017-01-20-model-driven-telemetry-dial-in-or-dial-out": {
      "title": "Model-Driven Telemetry: Dial-In or Dial-Out ?",
      "content": "     Dial-In or Dial-Out?  Transport Options  Dial-Out Vs. Dial-In  TCP Dial-Out  gRPC Dial-Out  gRPC Dial-In  Decisions, Decisions  Transport OptionsIn one of my first tutorials on configuring Model-Driven Telemetry (MDT), I blithely referred to three options for transport# TCP dial-out, gRPC dial-out and gRPC dial-in.  It’s all well and good to know how to configure each one, but what’s the difference and which one should you choose?  This blog tackles those questions.Dial-Out Vs. Dial-InWhen we say “dial-out,” we are speaking from the router’s perspective# the router “dials out” to the collector.  In other words, the router sends the SYN packet in the TCP handshake.Anyone who has had to modify ACLs to enable a new SNMP manager to connect to the network can appreciate the value of the dial-out option.  Since the router initiates the connection, you don’t have to worry about opening up ports for inbound management traffic.  Dial-out can also leverage Anycast addresses for HA and/or load-balancing.With dial-in, on the other hand, the router listens passively on a specified port until the collector “dials-in.”After the initial session establishment, the router still pushes the data off the box at the configured interval.  This is very important!  Don’t be fooled by the direction of the SYN packet.  There is no polling mechanism in MDT.Dial-in appeals to folks who are looking for a “single channel” to communicate with the network.  These are operators who want a single transport and protocol for both configuration data and streaming operational data. Sound impossible?  Well, we’re already doing it today.TCP Dial-OutOur first dial-out protocol was also the simplest# plain old TCP.  Open up a raw TCP socket on your collector and the router will complete the standard three-way handshake and start pushing telemetry data across the session.  No fancy programming libraries are required on the collector – in python it’s a simple matter of a “bind” to the port.  TCP dial-out inherits all the goodness of TCP (reliable delivery, fragmentation, re-ordering, etc) without having to invent a new protocol or define new mechanisms.  It’s a great place to start if you’re configuring MDT for the first time.gRPC Dial-OutOne of TCP’s great strengths is its simplicity.  But TCP by itself lacks higher-level functions that can enable more secure and sophisticated communication between the router and the collector.  For that, we turned to gRPC.gRPC is an open source communication framework built on top of HTTP/2.  It was originally designed by Google to enable efficient, accurate and low-latency communication between clients and servers.  It has many functions beyond those required by MDT.One of the main reasons that people enable gRPC dial-out is that gRPC allows you to do authentication and encryption via TLS.  If you’re worried about sending operational data in the clear and/or you want to protect your collector with certificate-based authentication, enable gRPC with TLS.Another bonus is that gRPC handles pesky details around async communications and the associated file descriptor handling. So you might actually find it easier to use than TCP as you scale to multiple routers.gRPC is not quite as trivial from a protocol perspective, but one of its strengths is the plethora of idiomatic client libraries in multiple programming languages.  Go, Python, Ruby, Java, C developers – grab your gRPC library from github and you’ll be juggling gRPC sessions like a pro.gRPC Dial-InIn addition to secure and efficient transport, gRPC provides bidirectional streaming and connection multiplexing.  This means that you can “dial-in” to a router, push down new configs (including telemetry subscription configs) and have operational data streamed back – all within a single, unified channel, all using the same underlying data models.  Cisco IOS XR has supported configuration via gRPC since 6.0.0 and dial-in telemetry over gRPC since 6.1.1.Since the collector “dials-in” to the router, there’s no need to specify each MDT destination in the configuration.  Just enable the gRPC service on the router, connect your client, and dynamically enable the telemetry subscription you want.Of course, like all the other methods, there are trade-offs. A dial-in subscription is transient.  If you lose it, the client (the collector) is responsible for re-establishing it.  You will also have to think more carefully about how you want to do load-balancing.Decisions, DecisionsSo what transport should you use for MDT?  Here’s a few quick heuristics#  If you’re looking for a quick and simple solution for a single router and collector, try TCP dial-out.  It’s simple to configure, there are no new protocols to learn, and you won’t have to worry about opening up inbound connections.  If you need encryption or you need help scaling out to many devices, take a look at gRPC dial-out.  If you’re already using gRPC for configuration, consider gRPC dial-in.As you deploy MDT, you may find that your transport needs change or evolve.  No problem.  The most important thing to remember is that the push mechanism for telemetry data remains exactly the same, dial-in or dial-out, TCP or gRPC.  No matter what you choose, you’ll get the same data, in the same data model, at the same speed.  That’s the beauty of Model-Driven Telemetry.",
      "url": "/blogs/2017-01-20-model-driven-telemetry-dial-in-or-dial-out/",
      "author": "Shelly Cadora",
      "tags": "cisco, MDT, telemetry"
    }
    
    ,
  
  
  
    "blogs-2017-06-21-building-a-ciscolive-demo-with-telemetry-and-kafka": {
      "title": "Enhancing a CiscoLive Demo with Telemetry and Kafka",
      "content": "     Enhancing Demos with Telemetry  Behind the Scenes of Continuous Automation  The Easy Part# Data Model and Router Config  The Other Easy Part# Pipeline and Kafka  The Easiest Part  A Quick Python Script  In Sum  Behind the Scenes of Continuous AutomationEvery year at Cisco Live, my team helps put together the demos that go into the World of Solutions. Geeks that we are, we get a thrill out of showing off the art of the possible. But the real purpose of a demo is to start a conversation with the folks who stop by our booth.This year, a colleague asked me to help integrate model-driven telemetry (MDT) into a Service Provider demo called “Continuous Automation.” The goal of the demo is to illustrate how MDT can be used with model-driven APIs to automate a simple provisioning and validation task (it’s loosely based on a real customer use case that he’s actively working on).Pieces of the demo were already in place# a small Python app that utilized the YDK Python APIs to configure a BGP neighbor and execute a connectivity test from the router when the neighbor came up.  The problem was that the app had no way to know when the neighbor came up.  Enter MDT!The Easy Part# Data Model and Router ConfigThe operational data that we needed was the BGP neighbor session state.  This is easily available in the OpenConfig BGP model#module# openconfig-bgp   +--rw bgp      +--rw neighbors         +--rw neighbor* [neighbor-address]            +--ro state               +--ro session-state?   enumerationTranslating this into an MDT sensor path config for the router looks like this#telemetry model-driven sensor-group BGP  sensor-path openconfig-bgp#bgp/neighbors/neighbor/stateNote# For a detailed explanation of MDT router configurations, see my basic MDT tutorial).Adding a destination-group and a subscription starts the router streaming out the needed data#telemetry model-driven destination-group G1  address-family ipv4 198.18.1.127 port 5432   encoding self-describing-gpb   protocol tcp  ! subscription S1  sensor-group-id BGP sample-interval 5000  destination-id G1But then what?  How do you get data from a TCP stream into a Python app?The Other Easy Part# Pipeline and KafkaMy go-to tool for consuming MDT data is pipeline, an open source utility that I’ve written about before.  If you’re not familiar with installing and configuring pipeline, have a read through my previous tutorial.For this demo, I used the  [testbed] input stage in the default pipeline.conf.  With the following lines uncommented, the default pipeline.conf will work “as-is” with the router MDT configuration in the previous section.[testbed]stage = xport_inputtype = tcpencap = stlisten = #5432That’s good for input, but what about output?  Pipeline can write data to three destinations#- a file- time series databases like InfluxDB- KafkaWriting to a file would probably work (Python has extensive file handling capabilities) but it seemed clumsy.  Writing to InfluxDB would also have worked (I could use Python REST packages to query the database) but seemed too heavy weight for a simple demo.  That left me with Kafka.  I’ve been wanting to do a Kafka demo for a while and there are Python packages to work with Kafka, so I figured…why not?  If nothing else, I’ll learn something new.For pipeline to output to Kafka, all you have to do is uncomment the following lines in the [mykafka] section of the default pipeline.conf. In the example below, I’m running pipeline and Kafka on the same machine, so I used the broker address of “localhost” and the topic called “telemetry.”[mykafka]stage = xport_outputtype = kafkaencoding = jsonbrokers = localhost#9092topic = telemetryWith those two entries in the pipeline.conf file, I kicked off pipeline as usual#$ bin/pipeline &amp;[1] 21975Startup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]Wait for ^C to shutdown$The Easiest PartSince I haven’t installed Kafka before, I was concerned that it might be the long pole in my demo prep.  But it couldn’t have been easier.  I followed the first two steps in the Apache Kafka Quickstart guide.  Boom.  Done.  Didn’t even have to alter the default properties files for Kafka and Zookeeper.A Quick Python ScriptWith Kafka, Zookeeper and Pipeline running and the router streaming MDT, all I lacked was a little Python code to subscribe to the topic on Kafka and parse some JSON (by default, pipeline transforms the GPB from the router into a JSON object when it publishes to Kafka). With the kafka-python client, there wasn’t much to it.  Here are a few lines of code I used for a quick test (note that the topic is telemetry and the Pipeline/Kafka stack is running on 10.30.111.4)#from kafka import KafkaConsumerimport jsonif __name__ == ~__main__~#    session_state = ~UNKNOWN~    consumer = KafkaConsumer('telemetry', bootstrap_servers=[~10.30.111.4#9092~])    for msg in consumer#        telemetry_msg =  msg.value        telemetry_msg_json = json.loads(telemetry_msg)        if ~Rows~ in telemetry_msg_json#            content_rows = telemetry_msg_json[~Rows~]            for row in content_rows#            if row[~Keys~][~neighbor-address~] == '10.8.0.1'#                    new_session_state = row[~Content~][~session-state~]                    if session_state != new_session_state#                        print(~\\nSession state changed from {0#s} to {1#s} at epoch time {2#d}~                              .format(session_state, new_session_state, row[~Timestamp~]))                        session_state = new_session_stateIn SumThere was a little more code to write to tie everything together and tidy it up, but my part of the demo was basically done.  From a telemetry perspective, it was trivial to integrate into the demo by using Kafka.  To recap, the main pieces were#- Configure the router to stream BGP session state.- Configure (basically uncomment some lines in the default pipeline.conf) and run pipeline.- Download and run Kafka and Zookeeper.- Use the kafka-python package in a Python script to acquire and process the session state from the telemetry topic on Kafka.Although I didn’t get the learning experience that comes from having really complicated things go deeply wrong, this was a fun little exercise.If you’re in Las Vegas for CiscoLive next week, stop by our booth and talk to us about what you want to do in a model-driven network!",
      "url": "/blogs/2017-06-21-building-a-ciscolive-demo-with-telemetry-and-kafka/",
      "author": "Shelly Cadora",
      "tags": "iosxr, cisco, Telemetry, MDT, YDK, Kafka"
    }
    
    
  
,

  
  
  
  
     "#": {}
   ,
   
    
  
  
  
     "#": {}
   ,
   
    
  
  
  
    "techdocs-app-hosting-on-iosxr-xr-linux-shell": {
      "title": "XR Linux Shell",
      "content": "Minimal Mistakes has been developed to be 100% compatible with hosting a site on GitHub Pages. To get up and running with a new GitHub repository quickly, follow these steps or jump ahead to the full installation guide.Fork the ThemeFork the Minimal Mistakes theme, then rename the repo to USERNAME.github.io &#8212; replacing USERNAME with your GitHub username.  Note# Your Jekyll site should be viewable immediately at http#//USERNAME.github.io. If it&#8217;s not, you can force a rebuild by Customizing Your Site (see below for more details).If you&#8217;re hosting several Jekyll based sites under the same GitHub username you will have to use Project Pages instead of User Pages. Essentially you rename the repo to something other than USERNAME.github.io and create a gh-pages branch off of master. For more details on how to set things up check GitHub&#8217;s documentation.  ProTip# Be sure to delete the gh-pages branch if you forked Minimal Mistakes. This branch contains the documentation and demo site for the theme and you probably don&#8217;t want that showing up in your repo.Customize Your SiteOpen up _config.yml found in the root of the repo and edit anything under Site Settings. For a full explanation of every setting be sure to read the Configuration section, but for now let&#8217;s just change the site&#8217;s title.    Edit text files without leaving GitHub.comCommitting a change to _config.yml (or any file in your repository) will force GitHub Pages to rebuild your site with Jekyll. It should then be viewable a few seconds later at https#//USERNAME.github.io.Congratulations! You&#8217;ve successfully forked the theme and are up an running with GitHub Pages. Now you&#8217;re ready to add content and customize the site further.",
      "url": "/techdocs/app_hosting_on_iosxr/xr_linux_shell",
      "tags": ""
    }
    
    
  
,

  
  
  
    
    "tutorials-2016-06-23-copying-telemetry-policy-files-in-ios-xr-6-0-1": {
      "title": "Copying Telemetry Policy Files in IOS XR 6.0.1",
      "content": "Due to some general security improvements in 6.0.1, it’s not possible to sftp/scp files directly to the /telemetry/policies directory from the outside.  If you try, you might see something like this#RP/0/RP0/CPU0#Sun601#run[xr-vm_node0_RP0_CPU0#~]$sftp scadora@172.30.8.11 Connecting to 172.30.8.11...  Password#  sftp&gt;get /tftpboot/BasicPolicy.policy /telemetry/policies/BasicPolicy.policy   RP/0/RP0/CPU0#Jun 23 16#08#00.870 # sftp[69048]# %SECURITY-SSHD-3-ERR_GENERAL # Cannot     overwrite system files  sftp&gt;The restriction on the /telemetry/policies directory will be lifted in 6.0.2, but in the meantime you can work around this by copying files to disk0# and then doing a local copy to the proper directory as follows#RP/0/RP0/CPU0#Sun601#run[xr-vm_node0_RP0_CPU0#~]$sftp scadora@172.30.8.11Connecting to 172.30.8.11...  Password#  sftp&gt; get /tftpboot/BasicPolicy.policy /disk0#/BasicPolicy.policy  Transferred 469 Bytes    469 bytes copied in 0 sec (0)bytes/sec  sftp&gt; quit  [xr-vm_node0_RP0_CPU0#~]$cp /disk0#/BasicPolicy.policy /telemetry/policies[xr-vm_node0_RP0_CPU0#~]$",
      "url": "/tutorials/2016-06-23-copying-telemetry-policy-files-in-ios-xr-6-0-1/",
      "author": "Shelly Cadora",
      "tags": "iosxr, telemetry"
    }
    
    ,
  
  
    
    "tutorials-2016-07-21-configuring-model-driven-telemetry-mdt": {
      "title": "Configuring Model-Driven Telemetry (MDT)",
      "content": "     Configuring Model-Driven Telemetry (MDT)  Important Background (aka TL;DR)  Using TCP Dial-Out          TCP Dial-Out Router Config        Using gRPC Dial-Out          gRPC Dial-Out Router Config        Using gRPC Dial-In          gRPC Dial-In Router Config        Important Background (aka TL;DR)Before configuring Model-Driven Telemetry, you should understand the different options that are available for transport, session initation and encoding and pick the combination that works for you.  Here’s a quick summary#  Transport# The router can deliver telemetry data either across using TCP or gRPC over HTTP/2.  Some people will prefer the simplicity of a raw TCP socket, others will appreciate the optional TLS encyption that gRPC brings.  Session Initiation# There are two options for initiating a telemetry session.  The router can “dial-out” to the collector or the collector can “dial-in” to the router.  Regardless of which side initiates the session, the router always streams the data to the collector at the requested intervals. TCP supports “dial-out” while gRPC supports both “dial-in” and “dial-out.”  Encoding# The router can deliver telemetry data in two different flavors of Google Protocol Buffers# Compact and Self-Describing GPB.  Compact GPB is the most efficient encoding but requires a unique .proto for each YANG model that is streamed.  Self-describing GPB is less efficient but it uses a single .proto file to decode all YANG models because the keys are passed as strings in the .proto.This tutorial covers the detailed configuration steps for three combinations# TCP Dial-Out, gRPC Dial-Out and gRPC Dial-In, all using the self-describing GPB encoding.Using TCP Dial-OutWith the TCP Dial-Out method, the router initiates a TCP session to the collector and sends whatever data is specified by the sensor-group in the subscription.TCP Dial-Out Router ConfigThere are three steps to configuring the router for telemetry with TCP dial-out# create a destination-group, create a sensor-group, create a subscription.Step 1# Create a destination-groupThe destination-group specifies the destination address, port, encoding and transport that the router should use to send out telemetry data.  In this case, we configure the router to send telemetry via tcp, encoding as self-describing gpb, to 172.30.8.4 port 5432.RP/0/RP0/CPU0#SunC(config)# telemetry model-drivenRP/0/RP0/CPU0#SunC(config-model-driven)# destination-group DGroup1 RP/0/RP0/CPU0#SunC(config-model-driven-dest)#  address family ipv4 172.30.8.4 port 5432  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)#   encoding self-describing-gpb  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)#   protocol tcp  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)# commit   Step 2# Create a sensor-groupThe sensor-group specifies a list of YANG models which are to be streamed.  The sensor path below represents the XR YANG model for interfaces statistics#RP/0/RP0/CPU0#SunC(config)#telemetry model-drivenRP/0/RP0/CPU0#SunC(config-model-driven)#sensor-group SGroup1RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-countersRP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# commitStep 3# Create a subscriptionThe subscription associates a destination-group with a sensor-group and sets the streaming interval.  The following configuration associates the sensor-group and destination created above with a streaming interval of 30 seconds.RP/0/RP0/CPU0#SunC(config)telemetry model-driven  RP/0/RP0/CPU0#SunC(config-model-driven)#subscription Sub1  RP/0/RP0/CPU0#SunC(config-model-driven-subs)#sensor-group-id SGroup1 sample-interval 30000  RP/0/RP0/CPU0#SunC(config-model-driven-subs)#destination-id DGroup1  RP/0/RP0/CPU0#SunC(config-mdt-subscription)# commit  All Together NowHere’s the entire configuration for TCP dial-out with GPB encoding in one shot#telemetry model-driven   destination-group DGroup1     address family ipv4 172.30.8.4 port 5432     encoding self-describing-gpb     protocol tcp  ! ! sensor-group SGroup1  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters !   subscription Sub1    sensor-group-id SGroup1 sample-interval 30000    destination-id DGroup1   ValidationUse the following command to verify that you have correctly configured the router for TCP dial-out.RP/0/RP0/CPU0#SunC#show telemetry model-driven subscriptionThu Jul 21 15#42#27.751 UTCSubscription#  Sub1                     State# ACTIVE-------------  Sensor groups#  Id                Interval(ms)        State  SGroup1           30000               Resolved  Destination Groups#  Id                Encoding            Transport   State   Port    IP  DGroup1           self-describing-gpb tcp         Active  5432    172.30.8.4Using gRPC Dial-OutWith the gRPC Dial-Out method, the router initiates a gRPC session to the collector and sends whatever data is specified by the sensor-group in the subscription.gRPC Dial-Out Router ConfigThe steps to configure gRPC dial-out are the same as TCP dial-out# create a destination-group, create a sensor-group, create a subscription.Step 1# Create a destination-groupThe destination-group specifies the destination address, port, encoding and transport that the router should use to send out telemetry data.  In this case, we configure the router to send telemetry via gRPC, encoding as self-describing gpb, to 172.30.8.4 port 57500.RP/0/RP0/CPU0#SunC(config)#telemetry model-driven  RP/0/RP0/CPU0#SunC(config-model-driven)# destination-group DGroup2  RP/0/RP0/CPU0#SunC(config-model-driven-dest)#  address family ipv4 172.30.8.4 port 57500  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)#   encoding self-describing-gpb  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)#   protocol grpc  RP/0/RP0/CPU0#SunC(config-model-driven-dest-addr)# commit  Step 2# Create a sensor-groupThe sensor-group specifies a list of YANG models which are to be streamed.  The sensor path below represents the XR YANG model for summarized memory statistics#RP/0/RP0/CPU0#SunC(config)#telemetry model-driven   RP/0/RP0/CPU0#SunC(config-model-driven)#sensor-group SGroup2  RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# sensor-path Cisco-IOS-XR-nto-misc-oper#memory-summary/nodes/node/summary  RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# commit  Step 3# Create a subscriptionThe subscription associates a destination-group with a sensor-group and sets the streaming interval.  The following configuration associates the sensor-group and destination created above with a streaming interval of 30 seconds.RP/0/RP0/CPU0#SunC(config)telemetry model-driven  RP/0/RP0/CPU0#SunC(config-model-driven)#subscription Sub2  RP/0/RP0/CPU0#SunC(config-model-driven-subs)#sensor-group-id SGroup2 sample-interval 30000  RP/0/RP0/CPU0#SunC(config-model-driven-subs)#destination-id DGroup2  RP/0/RP0/CPU0#SunC(config-mdt-subscription)# commit  All Together NowHere’s the entire configuration for gRPC dial-out with GPB encoding in one shot#telemetry model-driven destination-group DGroup2  address family ipv4 172.30.8.4 port 57500   encoding self-describing-gpb   protocol grpc  ! ! sensor-group SGroup2  sensor-path Cisco-IOS-XR-nto-misc-oper#memory-summary/nodes/node/summary ! subscription Sub2  sensor-group-id SGroup2 sample-interval 30000  destination-id DGroup2ValidationUse the following command to verify that you have correctly configured the router for gRPC dial-out.RP/0/RP0/CPU0#SunC#show telemetry model-driven subscriptionThu Jul 21 21#14#08.636 UTCSubscription#  Sub2                     State# ACTIVE-------------  Sensor groups#  Id                Interval(ms)        State  SGroup2           30000               Resolved  Destination Groups#  Id                Encoding            Transport   State   Port    IP  DGroup2           self-describing-gpb grpc        NA      57500   172.30.8.4Using gRPC Dial-InWith the gRPC Dial-In method, the collector initiates a gRPC session to the collector.  The router sends whatever data is specified by the sensor-group in the subscription requested by the collector.gRPC Dial-In Router ConfigThere are three steps to configure gRPC dial-out# enable gRPC, create a sensor-group, create a subscription.Step 1# Enable gRPCThe following configuration enables the router’s gRPC server to accept incoming connections from the collector.RP/0/RP0/CPU0#SunC(config)#grpc  RP/0/RP0/CPU0#SunC(config-grpc)#port 57500  RP/0/RP0/CPU0#SunC(config-grpc)#commit  Step 2# Create a sensor-groupThe sensor-group specifies a list of YANG models which are to be streamed.  The sensor path below represents the OpenConfig YANG model for interfaces#RP/0/RP0/CPU0#SunC(config)#telemetry model-driven   RP/0/RP0/CPU0#SunC(config-model-driven)#sensor-group SGroup3  RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# sensor-path openconfig-interfaces#interfaces/interface  RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# commit  Step 3# Create a subscriptionThe subscription associates a sensor-group with the streaming interval.  No destination group is required because the collector will be dialing in.  The collector will need to request subscription “Sub3” when it connects.RP/0/RP0/CPU0#SunC(config)telemetry model-driven  RP/0/RP0/CPU0#SunC(config-model-driven)#subscription Sub3  RP/0/RP0/CPU0#SunC(config-model-driven-subs)#sensor-group-id SGroup3 sample-interval 30000  RP/0/RP0/CPU0#SunC(config-mdt-subscription)# commit  All Together NowHere’s the entire configuration for gRPC dial-in in one shot#grpc port 57500!telemetry model-driven sensor-group SGroup3  sensor-path openconfig-interfaces#interfaces/interface ! subscription Sub3  sensor-group-id SGroup3 sample-interval 30000ValidationUse the following command to verify that you have correctly configured the router for gRPC dial-in.RP/0/RP0/CPU0#SunC#show telemetry model-driven subscription Sub3Thu Jul 21 21#32#45.365 UTCSubscription#  Sub3-------------  State#       ACTIVE  Sensor groups#  Id# SGroup3    Sample Interval#      30000 ms    Sensor Path#          openconfig-interfaces#interfaces/interface    Sensor Path State#    Resolved  Destination Groups#  Group Id# DialIn_1002    Destination IP#       172.30.8.4    Destination Port#     44841    Encoding#             self-describing-gpb    Transport#            dialin    State#                Active    Total bytes sent#     13909    Total packets sent#   14    Last Sent time#       2016-07-21 21#32#25.231964501 +0000  Collection Groups#  ------------------    Id# 2    Sample Interval#      30000 ms    Encoding#             self-describing-gpb    Num of collection#    7    Collection time#      Min#    32 ms Max#    39 ms    Total time#           Min#    34 ms Avg#    37 ms Max#    40 ms    Total Deferred#       0    Total Send Errors#    0    Total Send Drops#     0    Total Other Errors#   0    Last Collection Start#2016-07-21 21#32#25.231930501 +0000    Last Collection End#  2016-07-21 21#32#25.231969501 +0000    Sensor Path#          openconfig-interfaces#interfaces/interface",
      "url": "/tutorials/2016-07-21-configuring-model-driven-telemetry-mdt/",
      "author": "Shelly Cadora",
      "tags": "iosxr, Telemetry, MDT"
    }
    
    ,
  
  
    
    "tutorials-2016-07-25-configuring-model-driven-telemetry-mdt-with-yang": {
      "title": "Configuring Model-Driven Telemetry (MDT) with OpenConfig YANG",
      "content": "     Configuring MDT with OpenConfig YANG  Model-Driven Configuration for Model-Driven Telemetry  The Models  Get-Config  Edit-Config  Conclusion  Model-Driven Configuration for Model-Driven TelemetryIn an earlier tutorial, I wrote about how to configure MDT using CLI.  But if the router is using YANG models to structure the operational data it streams, shouldn’t we also be able to use models to configure the telemetry feature itself?  The answer is yes!  In this tutorial, we’ll look at the OpenConfig YANG model for telemetry and how to configure it.  I will use ncclient as a simple Python NETCONF client, but you can use whatever client you want.The ModelsLet’s start with a quick look at the NETCONF capabilities list from IOS XR 6.1.1.  This bit of code#from ncclient import managerimport re    xr = manager.connect(host='10.30.111.9', port=830, username='cisco', password='cisco',\tallow_agent=False,\tlook_for_keys=False,\thostkey_verify=False,\tunknown_host_cb=True)for c in xr.server_capabilities#    model = re.search('module=([^&amp;]*telemetry[^&amp;]*)&amp;', c)    if model is not None#        print model.group(1)     …tells us that there are two models for telemetry configuration#Script Output#openconfig-telemetryCisco-IOS-XR-telemetry-model-driven-cfgThe first model is the OpenConfig telemetry model and the second is the XR native telemetry model.  If you look at them in detail, you will notice that the native model closely follows the OpenConfig model, although the native model will let you do things that are supported by IOS XR but not defined by this version of OpenConfig (like disabling TLS or enabling dial-out).  In this tutorial, I’ll focus on openconfig-telemetry, but you could do everything with Cisco-IOS-XR-telemetry-model-driven-cfg as well.The NETCONF &lt;get-schema&gt; operation will give you the contents of the schema but the full YANG output can be really verbose and overwhelming, so I’ll pipe the output to the pyang utility for a compact tree view with the following bit of code#from subprocess import Popen, PIPE, STDOUToc = xr.get_schema('openconfig-telemetry')p = Popen(['pyang', '-f', 'tree'], stdout=PIPE, stdin=PIPE, stderr=PIPE) print(p.communicate(input=oc.data)[0])And voila#Script Output#module# openconfig-telemetry   +--rw telemetry-system      +--rw sensor-groups      |  +--rw sensor-group* [sensor-group-id]      |     +--rw sensor-group-id    -&gt; ../config/sensor-group-id      |     +--rw config      |     |  +--rw sensor-group-id?   string      |     +--ro state      |     |  +--ro sensor-group-id?   string      |     +--rw sensor-paths      |        +--rw sensor-path* [path]      |           +--rw path      -&gt; ../config/path      |           +--rw config      |           |  +--rw path?             string      |           |  +--rw exclude-filter?   string      |           +--ro state      |              +--ro path?             string      |              +--ro exclude-filter?   string      +--rw destination-groups      |  +--rw destination-group* [group-id]      |     +--rw group-id        -&gt; ../config/group-id      |     +--rw config      |     |  +--rw group-id?   string      |     +--ro state      |     |  +--ro group-id?   string      |     +--rw destinations      |        +--rw destination* [destination-address destination-port]      |           +--rw destination-address    -&gt; ../config/destination-address      |           +--rw destination-port       -&gt; ../config/destination-port      |           +--rw config      |           |  +--rw destination-address?    inet#ip-address      |           |  +--rw destination-port?       uint16      |           |  +--rw destination-protocol?   telemetry-stream-protocol      |           +--ro state      |              +--ro destination-address?    inet#ip-address      |              +--ro destination-port?       uint16      |              +--ro destination-protocol?   telemetry-stream-protocol      +--rw subscriptions         +--rw persistent         |  +--rw subscription* [subscription-id]         |     +--rw subscription-id       -&gt; ../config/subscription-id         |     +--rw config         |     |  +--rw subscription-id?          uint64         |     |  +--rw local-source-address?     inet#ip-address         |     |  +--rw originated-qos-marking?   inet#dscp         |     +--ro state         |     |  +--ro subscription-id?          uint64         |     |  +--ro local-source-address?     inet#ip-address         |     |  +--ro originated-qos-marking?   inet#dscp         |     +--rw sensor-profiles         |     |  +--rw sensor-profile* [sensor-group]         |     |     +--rw sensor-group    -&gt; ../config/sensor-group         |     |     +--rw config         |     |     |  +--rw sensor-group?         -&gt; /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id         |     |     |  +--rw sample-interval?      uint64         |     |     |  +--rw heartbeat-interval?   uint64         |     |     |  +--rw suppress-redundant?   boolean         |     |     +--ro state         |     |        +--ro sensor-group?         -&gt; /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id         |     |        +--ro sample-interval?      uint64         |     |        +--ro heartbeat-interval?   uint64         |     |        +--ro suppress-redundant?   boolean         |     +--rw destination-groups         |        +--rw destination-group* [group-id]         |           +--rw group-id    -&gt; ../config/group-id         |           +--rw config         |           |  +--rw group-id?   -&gt; ../../../../../../../destination-groups/destination-group/group-id         |           +--rw state         |              +--rw group-id?   -&gt; ../../../../../../../destination-groups/destination-group/group-id         +--rw dynamic            +--ro subscription* [subscription-id]               +--ro subscription-id    -&gt; ../state/subscription-id               +--ro state               |  +--ro subscription-id?          uint64               |  +--ro destination-address?      inet#ip-address               |  +--ro destination-port?         uint16               |  +--ro destination-protocol?     telemetry-stream-protocol               |  +--ro sample-interval?          uint64               |  +--ro heartbeat-interval?       uint64               |  +--ro suppress-redundant?       boolean               |  +--ro originated-qos-marking?   inet#dscp               +--ro sensor-paths                  +--ro sensor-path* [path]                     +--ro path     -&gt; ../state/path                     +--ro state                        +--ro path?             string                        +--ro exclude-filter?   stringYou can spend a lot of time understanding the intricacies of YANG and all the details, but all we really need to know for now is that the model has three major sections#  The destination-group tells the router where to send telemetry data and how. Only needed for dial-out configuration.  The sensor-group identifies a list of YANG models that the router should stream.  The subscription ties together the destination-group and the sensor-group.Let’s see how this works in practice.Get-ConfigWe can use the openconfig-telemetry model to filter for the telemetry config with the ncclient get_config operation#filter = '''&lt;telemetry-system xmlns=~http#//openconfig.net/yang/telemetry~&gt;'''c = xr.get_config(source='running', filter=('subtree', filter))print(c)And here’s what we get#Script Output#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#939c718e-81ee-43ec-9733-565aa53fedb2~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;telemetry-system xmlns=~http#//openconfig.net/yang/telemetry~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-id&gt;SGroup3&lt;/sensor-group-id&gt;     &lt;config&gt;      &lt;sensor-group-id&gt;SGroup3&lt;/sensor-group-id&gt;     &lt;/config&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;path&gt;openconfig-interfaces#interfaces/interface&lt;/path&gt;       &lt;config&gt;        &lt;path&gt;openconfig-interfaces#interfaces/interface&lt;/path&gt;       &lt;/config&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;   &lt;subscriptions&gt;    &lt;persistent&gt;     &lt;subscription&gt;      &lt;subscription-id&gt;Sub3&lt;/subscription-id&gt;      &lt;config&gt;       &lt;subscription-id&gt;Sub3&lt;/subscription-id&gt;      &lt;/config&gt;      &lt;sensor-profiles&gt;       &lt;sensor-profile&gt;        &lt;sensor-group&gt;SGroup3&lt;/sensor-group&gt;        &lt;config&gt;         &lt;sensor-group&gt;SGroup3&lt;/sensor-group&gt;         &lt;sample-interval&gt;30000&lt;/sample-interval&gt;        &lt;/config&gt;       &lt;/sensor-profile&gt;      &lt;/sensor-profiles&gt;     &lt;/subscription&gt;    &lt;/persistent&gt;   &lt;/subscriptions&gt;  &lt;/telemetry-system&gt; &lt;/data&gt;&lt;/rpc-reply&gt;So what does all that mean to the router?  It breaks down into three parts which you’ll recall from the YANG model above#  The destination-group tells the router where to send telemetry data and how.  The absence of a destination-group in the output above alerts us to the fact that this is a dial-in configuration (the collector will initiate the session to the router).  The sensor-group identifies a list of YANG models that the router should stream.  In this case, the router has a sensor-group called “SGroup3” that will send interface statistics data from the OpenConfig Interfaces YANG model.  The subscription ties together the destination-group and the sensor-group.  This router has a subscription name “Sub3” that will send the list of models in SGroup3 at an interval of 30 second (30000 milleseconds).If you read the earlier tutorial on configuring MDT with CLI, you might recognize this as the same as the gRPC dial-in configuration described there.  If you missed that thrilling installment, the XML above is the YANG equivalent of this CLI#CLI Output#telemetry model-driven sensor-group SGroup3  sensor-path openconfig-interfaces#interfaces/interface ! subscription Sub3  sensor-group-id SGroup3 sample-interval 30000 !  Edit-ConfigSo let’s say we want to add a second model to SGroup3 (Cisco-IOS-XR-ipv4-arp-oper).  We can do that with the following NETCONF operations#edit_data = '''&lt;config&gt;&lt;telemetry-system xmlns=~http#//openconfig.net/yang/telemetry~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-id&gt;SGroup3&lt;/sensor-group-id&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;config&gt;        &lt;path&gt;Cisco-IOS-XR-ipv4-arp-oper#arp/nodes/node/entries/entry&lt;/path&gt;       &lt;/config&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;&lt;/config&gt;'''xr.edit_config(edit_data, target='candidate', format='xml')xr.commit()If we do a get-config operation again#c = xr.get_config(source='running', filter=('subtree', filter))print(c)… we’ll see that SGroup3 has the new addition.Script Output#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#abd0a7ee-5f06-4754-b2a3-dae6e3d797aa~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;telemetry-system xmlns=~http#//openconfig.net/yang/telemetry~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-id&gt;SGroup3&lt;/sensor-group-id&gt;     &lt;config&gt;      &lt;sensor-group-id&gt;SGroup3&lt;/sensor-group-id&gt;     &lt;/config&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;path&gt;openconfig-interfaces#interfaces/interface&lt;/path&gt;       &lt;config&gt;        &lt;path&gt;openconfig-interfaces#interfaces/interface&lt;/path&gt;       &lt;/config&gt;      &lt;/sensor-path&gt;      &lt;sensor-path&gt;       &lt;path&gt;Cisco-IOS-XR-ipv4-arp-oper#arp/nodes/node/entries/entry&lt;/path&gt;       &lt;config&gt;        &lt;path&gt;Cisco-IOS-XR-ipv4-arp-oper#arp/nodes/node/entries/entry&lt;/path&gt;       &lt;/config&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;   &lt;subscriptions&gt;    &lt;persistent&gt;     &lt;subscription&gt;      &lt;subscription-id&gt;Sub3&lt;/subscription-id&gt;      &lt;config&gt;       &lt;subscription-id&gt;Sub3&lt;/subscription-id&gt;      &lt;/config&gt;      &lt;sensor-profiles&gt;       &lt;sensor-profile&gt;        &lt;sensor-group&gt;SGroup3&lt;/sensor-group&gt;        &lt;config&gt;         &lt;sensor-group&gt;SGroup3&lt;/sensor-group&gt;         &lt;sample-interval&gt;30000&lt;/sample-interval&gt;        &lt;/config&gt;       &lt;/sensor-profile&gt;      &lt;/sensor-profiles&gt;     &lt;/subscription&gt;    &lt;/persistent&gt;   &lt;/subscriptions&gt;  &lt;/telemetry-system&gt; &lt;/data&gt;&lt;/rpc-reply&gt;And if you need some CLI to reassure yourself that it worked, here it is#CLI Output#RP/0/RP0/CPU0#SunC#show run telemetry model-drivenMon Aug  8 20#09#57.149 UTCtelemetry model-driven sensor-group SGroup3  sensor-path openconfig-interfaces#interfaces/interface  sensor-path Cisco-IOS-XR-ipv4-arp-oper#arp/nodes/node/entries/entry ! subscription Sub3  sensor-group-id SGroup3 sample-interval 30000 !!ConclusionArmed with the examples in this blog and a understanding of the telemetry YANG model, you should now be able to use YANG configuration models to configure the router to stream YANG models with the operational data you want.  How’s that for model-driven programmability?",
      "url": "/tutorials/2016-07-25-configuring-model-driven-telemetry-mdt-with-yang/",
      "author": "Shelly Cadora",
      "tags": "iosxr, YANG, telemetry, MDT"
    }
    
    ,
  
  
    
    "tutorials-2016-08-08-configuring-model-driven-telemetry-with-ydk": {
      "title": "Configuring Model-Driven Telemetry (MDT) with YDK",
      "content": "     Configuring MDT with YDK  YDK# Automating YANG without XML  Connect to the router  Define the sensor group  Apply the SensorGroup object to the router  Instantiate a Subscription object and apply it  What did all that code do?  Clean up, clean up, everybody clean up!  Conclusion  YDK# Automating YANG without XMLIn an earlier tutorial, I wrote about how to configure MDT using the OpenConfig Telemetry YANG model with ncclient and a lot of XML.  An even simpler way to do this is to use YDK, a developer toolkit that automatically generates APIs directly from YANG models.  The Python classes that are generated by YDK mirror the YANG model hierarchy. So if you know some Python and you understand the YANG model, you can start writing code, no knowledge of NETCONF or XML required.In this blog, I’ll explain how to configure telemetry for gRPC dialin using YDK and the OpenConfig Telemetry YANG model.Connect to the routerYDK leverages ncclient to handle the NETCONF connection, so this bit of code might look similar to what you’ve done before, using the YDK provider library instead of ncclient#from ydk.providers import NetconfServiceProviderfrom ydk.services import CRUDService HOST = '10.30.111.9'PORT = 830USER = 'cisco'PASS = 'cisco'xr = NetconfServiceProvider(address=HOST,\tport=PORT,\tusername=USER,\tpassword=PASS,\tprotocol = 'ssh')With that, we are now connected to the router#CLI Output#RP/0/RP0/CPU0#SunC#show netconf-yang clientsMon Aug  8 23#01#48.210 UTCNetconf clientsclient session ID|     NC version|    client connect time|        last OP time|        last OP type|    &lt;lock&gt;|       1386485520|            1.1|         0d  0h  0m  5s|                    |                    |        No|RP/0/RP0/CPU0#SunC#Define the sensor groupNow that our script is connected to the router, we’ll start by defining the sensor-group.  Here’s the first bit of YDK for that#import ydk.models.openconfig.openconfig_telemetry as oc_telemetry sgroup = oc_telemetry.TelemetrySystem.SensorGroups.SensorGroup()sgroup.sensor_group_id=~SGroup4~sgroup.config.sensor_group_id=~SGroup4~So how did I come up with that?  Look back at the first part of the OC Telemetry YANG model#PYANG Output#module# openconfig-telemetry   +--rw telemetry-system      +--rw sensor-groups      |  +--rw sensor-group* [sensor-group-id]      |     +--rw sensor-group-id    -&gt; ../config/sensor-group-id      |     +--rw config      |     |  +--rw sensor-group-id?   string   Start from the top and walk down from telemetry-system to sensor-groups to sensor-group.  Replace the dashes and lowercase syntax with CamelCase syntax and you get the class that instantiates that first object# TelemetrySystem.SensorGroups.SensorGroup().  Down to the next level, we have the leaf “sensor-group-id.”  YDK converts this to an object attribute by replacing the hyphens with underscores.  The sensor-group-id list key is actually a leaf-ref to config/sensor-group-id, both of which are required (hence the two lines that seem redundant but are actually required for syntactic validation because of the structure of the YANG model).Going down a little farther in the YANG model with some help from some pyang options, we see that the sensor-group contains a list of sensor-paths.PYANG Output#$ pyang -f tree openconfig-telemetry.yang --tree-path=telemetry-system/sensor-groups/sensor-group/sensor-paths/sensor-path/configmodule# openconfig-telemetry   +--rw telemetry-system      +--rw sensor-groups         +--rw sensor-group* [sensor-group-id]            +--rw sensor-paths               +--rw sensor-path* [path]                  +--rw config                     +--rw path?             string$This is how that maps to YDK code#sgroup.sensor_paths = sgroup.SensorPaths()new_sensorpath = sgroup.SensorPaths.SensorPath()new_sensorpath.path = 'Cisco-IOS-XR-infra-statsd-oper#infra-statistics%2finterfaces%2finterface%2flatest%2fgeneric-counters'new_sensorpath.config.path = 'Cisco-IOS-XR-infra-statsd-oper#infra-statistics%2finterfaces%2finterface%2flatest%2fgeneric-counters'sgroup.sensor_paths.sensor_path.append(new_sensorpath)So again, following the YANG model, we define the top-level SensorPaths object, then a SensorPath with an object attribute “path” that actually specifies the YANG model that we want to stream (in this case, our old friend, interface statistics).Note that the “%2f” in the path attributes represent URL encodings of the forward slash character (“/”).  The code would look a little better if you used a utility such as urllib to do the string substitution for you, so you can use the more natural looking path with “/” characters like this#import urllibsgroup.sensor_paths = sgroup.SensorPaths()new_sensorpath = sgroup.SensorPaths.SensorPath()interface_stats_path = urllib.quote('Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters', safe='#')new_sensorpath.path = interface_stats_pathnew_sensorpath.config.path = interface_stats_pathsgroup.sensor_paths.sensor_path.append(new_sensorpath)Apply the SensorGroup object to the routerOnce you’ve populated the object, it’s trivial to apply it to the router using the create method on the CRUDService object from YDK#from ydk.services import CRUDServicerpc_service = CRUDService()rpc_service.create(xr, sgroup)Instantiate a Subscription object and apply itThe Subscription is the final piece of the config.  Again, refer to the YANG model to understand the Python class that you should use.  I’ll use pyang with the tree-path option to make it clearer#PYANG Output#$pyang -f tree --tree-path telemetry-system/subscriptions/persistent/subscription/sensor-profiles/sensor-profile openconfig-telemetry.yangmodule# openconfig-telemetry   +--rw telemetry-system      +--rw subscriptions         +--rw persistent            +--rw subscription* [subscription-id]               +--rw sensor-profiles                  +--rw sensor-profile* [sensor-group]                     +--rw sensor-group    -&gt; ../config/sensor-group                     +--rw config                     |  +--rw sensor-group?         -&gt; /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id                     |  +--rw sample-interval?      uint64                     |  +--rw heartbeat-interval?   uint64                     |  +--rw suppress-redundant?   boolean                     +--ro state                        +--ro sensor-group?         -&gt; /telemetry-system/sensor-groups/sensor-group/config/sensor-group-id                        +--ro sample-interval?      uint64                        +--ro heartbeat-interval?   uint64                        +--ro suppress-redundant?   boolean                     This is how that ends up in YDK code#sub = oc_telemetry.TelemetrySystem.Subscriptions.Persistent.Subscription()sub.subscription_id = 4sub.config.subscription_id = 4sub.sensor_profiles = sub.SensorProfiles()new_sgroup = sub.SensorProfiles.SensorProfile()new_sgroup.sensor_group = 'SGroup4'new_sgroup.config.sensor_group = 'SGroup4'new_sgroup.config.sample_interval = 30000sub.sensor_profiles.sensor_profile.append(new_sgroup)rpc_service.create(xr, sub)What did all that code do?So this is how all that shows up in CLI#CLI Output#RP/0/RP0/CPU0#SunC#show run telemetry model-drivenTue Aug  9 17#52#38.462 UTCtelemetry model-driven sensor-group SGroup4  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters ! subscription 4  sensor-group-id SGroup4 sample-interval 30000 !!RP/0/RP0/CPU0#SunC#And that is all you need for Model-Driven Telemetry using gRPC dialin.Clean up, clean up, everybody clean up!Let’s delete the telemetry config completely and disconnect the NETCONF session#rpc_service.delete(xr, oc_telemetry.TelemetrySystem())xr.close()ConclusionIn this tutorial, we looked at a couple dozen lines of YDK code that added and then removed five lines of CLI.  So you might be thinking “and that helps me be more efficient…how?”  But the power of automation in general and YDK in particular can’t be fully revealed in a single, simple example like this.  The real power of YDK is that it allows you to do this for any YANG model on the box, automatically generating Python classes that inherit the syntactic checks and requirements of the underlying model, while also handling all the details of the underlying encoding and transport (no understanding of XML or NETCONF chunk framing required!).  Give a try and see what you think!",
      "url": "/tutorials/2016-08-08-configuring-model-driven-telemetry-with-ydk/",
      "author": "Shelly Cadora",
      "tags": "cisco, YDK, telemetry, MDT, OpenConfig, YANG"
    }
    
    ,
  
  
    
    "tutorials-2016-08-15-configuring-mdt-for-tcp-dial-out-using-native-yang": {
      "title": "Configuring Model-Driven-Telemetry (MDT) for Dial-out Using Native YANG",
      "content": "     Configuring MDT dial-out using Native YANG  Getting the Most out of MDT with Native YANG  The Model  Get-Config  Edit-Config  Clean-up Time  Conclusion  Getting the Most out of MDT with Native YANGIn an earlier tutorial, I wrote about how to configure an MDT for gRPC dial-in using the OpenConfig Telemetry YANG model.  In this tutorial, I’ll describe how to use the IOS XR Native YANG model to configure MDT with TCP and gRPC dialout.  I will use ncclient as a simple Python NETCONF client, but you can use whatever client you want.The ModelThe Cisco IOS XR Native YANG model for telemetry is “Cisco-IOS-XR-telemetry-model-driven-cfg.”  It can be used to configure any telemetry feature that IOS XR (unlike the OpenConfig telemetry model, which only covers a subset of IOS XR capabilities).The NETCONF &lt;get-schema&gt; operation will give you the contents of the schema but the full YANG output can be really verbose and overwhelming, so I’ll pipe the output to the pyang utility for a compact tree view with the following bit of code#from ncclient import managerimport re    xr = manager.connect(host='10.30.111.9', port=830, username='cisco', password='cisco',                    allow_agent=False,                    look_for_keys=False,                    hostkey_verify=False,                    unknown_host_cb=True)                    from subprocess import Popen, PIPE, STDOUToc = xr.get_schema('Cisco-IOS-XR-telemetry-model-driven-cfg')p = Popen(['pyang', '-f', 'tree'], stdout=PIPE, stdin=PIPE, stderr=PIPE) print(p.communicate(input=oc.data)[0])And voila#Script Output#module# Cisco-IOS-XR-telemetry-model-driven-cfg   +--rw telemetry-model-driven      +--rw sensor-groups      |  +--rw sensor-group* [sensor-group-identifier]      |     +--rw sensor-paths      |     |  +--rw sensor-path* [telemetry-sensor-path]      |     |     +--rw telemetry-sensor-path    string      |     +--rw enable?                    empty      |     +--rw sensor-group-identifier    xr#Cisco-ios-xr-string      +--rw subscriptions      |  +--rw subscription* [subscription-identifier]      |     +--rw source-address!      |     |  +--rw address-family    Af      |     |  +--rw ip-address?       inet#ipv4-address-no-zone      |     |  +--rw ipv6-address?     string      |     +--rw sensor-profiles      |     |  +--rw sensor-profile* [sensorgroupid]      |     |     +--rw sample-interval?      uint32      |     |     +--rw heartbeat-interval?   uint32      |     |     +--rw supress-redundant?    empty      |     |     +--rw sensorgroupid         xr#Cisco-ios-xr-string      |     +--rw destination-profiles      |     |  +--rw destination-profile* [destination-id]      |     |     +--rw enable?           empty      |     |     +--rw destination-id    xr#Cisco-ios-xr-string      |     +--rw source-qos-marking?        uint32      |     +--rw subscription-identifier    xr#Cisco-ios-xr-string      +--rw destination-groups      |  +--rw destination-group* [destination-id]      |     +--rw destinations      |     |  +--rw destination* [address-family]      |     |     +--rw address-family    Af      |     |     +--rw ipv4* [ipv4-address destination-port]      |     |     |  +--rw ipv4-address        inet#ip-address-no-zone      |     |     |  +--rw destination-port    xr#Cisco-ios-xr-port-number      |     |     |  +--rw protocol!      |     |     |  |  +--rw protocol        Proto-type      |     |     |  |  +--rw tls-hostname?   string      |     |     |  |  +--rw no-tls?         int32      |     |     |  +--rw encoding?           Encode-type      |     |     +--rw ipv6* [ipv6-address destination-port]      |     |        +--rw ipv6-address        xr#Cisco-ios-xr-string      |     |        +--rw destination-port    xr#Cisco-ios-xr-port-number      |     |        +--rw protocol!      |     |        |  +--rw protocol        Proto-type      |     |        |  +--rw tls-hostname?   string      |     |        |  +--rw no-tls?         int32      |     |        +--rw encoding?           Encode-type      |     +--rw destination-id    xr#Cisco-ios-xr-string      +--rw enable?               emptyYou can spend a lot of time understanding the intricacies of YANG and all the details, but all we really need to know for now is that the model has three major sections#      The destination-group tells the router where to send telemetry data and how. Only needed for dial-out configuration.        The sensor-group identifies a list of YANG models that the router should stream.        The subscription ties together the destination-group and the sensor-group.  Let’s see how this works in practice.Get-ConfigWe can use the openconfig-telemetry model to filter for the telemetry config with the ncclient get_config operation. Continuing our python script from above#xr_filter = '''&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;'''c = xr.get_config(source='running', filter=('subtree', xr_filter))print(c)And here’s what we get#Script Output#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#1ddd326c-e2c8-46b1-8433-11283799b9ce~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;destination-groups&gt;    &lt;destination-group&gt;     &lt;destination-id&gt;DGroup1&lt;/destination-id&gt;     &lt;destinations&gt;      &lt;destination&gt;       &lt;address-family&gt;ipv4&lt;/address-family&gt;       &lt;ipv4&gt;        &lt;ipv4-address&gt;172.30.8.4&lt;/ipv4-address&gt;        &lt;destination-port&gt;5432&lt;/destination-port&gt;        &lt;encoding&gt;self-describing-gpb&lt;/encoding&gt;        &lt;protocol&gt;         &lt;protocol&gt;tcp&lt;/protocol&gt;         &lt;tls-hostname&gt;&lt;/tls-hostname&gt;         &lt;no-tls&gt;0&lt;/no-tls&gt;        &lt;/protocol&gt;       &lt;/ipv4&gt;      &lt;/destination&gt;     &lt;/destinations&gt;    &lt;/destination-group&gt;   &lt;/destination-groups&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-identifier&gt;SGroup1&lt;/sensor-group-identifier&gt;     &lt;enable&gt;&lt;/enable&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;telemetry-sensor-path&gt;Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters&lt;/telemetry-sensor-path&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;   &lt;enable&gt;&lt;/enable&gt;   &lt;subscriptions&gt;    &lt;subscription&gt;     &lt;subscription-identifier&gt;Sub1&lt;/subscription-identifier&gt;     &lt;sensor-profiles&gt;      &lt;sensor-profile&gt;       &lt;sensorgroupid&gt;SGroup1&lt;/sensorgroupid&gt;       &lt;sample-interval&gt;30000&lt;/sample-interval&gt;      &lt;/sensor-profile&gt;     &lt;/sensor-profiles&gt;     &lt;destination-profiles&gt;      &lt;destination-profile&gt;       &lt;destination-id&gt;DGroup1&lt;/destination-id&gt;       &lt;enable&gt;&lt;/enable&gt;      &lt;/destination-profile&gt;     &lt;/destination-profiles&gt;    &lt;/subscription&gt;   &lt;/subscriptions&gt;  &lt;/telemetry-model-driven&gt; &lt;/data&gt;&lt;/rpc-reply&gt;So what does all that mean to the router?  It breaks down into three parts which you’ll recall from the YANG model above#      The destination-group tells the router where to send telemetry data and how.  The destination group in this configuration (“DGroup1”) will send telemetry data to an IPv4 address (172.30.8.4) on port 5432 with a self-describing GPB encoding via TCP.        The sensor-group identifies a list of YANG models that the router should stream.  In this case, the router has a sensor-group called “SGroup1” that will send interface statistics data from the IOS XR Native YANG model for interface stats.        The subscription ties together the destination-group and the sensor-group.  This router has a subscription name “Sub1” that will send the list of models in SGroup1 to DGroup1 at an interval of 30 second (30000 milleseconds).  If you read the earlier tutorial on configuring MDT with CLI, you might recognize this as the same as the TCP dial-out configuration described there.  If you missed that thrilling installment, the XML above is the YANG equivalent of this CLI#CLI Output#telemetry model-driven   destination-group DGroup1     address family ipv4 172.30.8.4 port 5432     encoding self-describing-gpb     protocol tcp  ! ! sensor-group SGroup1  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters !   subscription Sub1    sensor-group-id SGroup1 sample-interval 30000    destination-id DGroup1 Edit-ConfigSo let’s say we want to add a second model (Cisco-IOS-XR-wdsysmon-fd-oper) to SGroup1 to stream cpu utilization data.  We can do that with the following NETCONF operations#edit_data = '''&lt;config&gt;&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-identifier&gt;SGroup1&lt;/sensor-group-identifier&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;telemetry-sensor-path&gt;Cisco-IOS-XR-wdsysmon-fd-oper#system-monitoring&lt;/telemetry-sensor-path&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;  &lt;/telemetry-model-driven&gt;&lt;/config&gt;'''xr.edit_config(edit_data, target='candidate', format='xml')xr.commit()If we do a get-config operation again, this time filtering on just the sensor-groups#xr_filter = '''&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;&lt;sensor-groups&gt;'''c = xr.get_config(source='running', filter=('subtree', xr_filter))print(c)… we’ll see that SGroup1 has the new sensor-path.Script Output#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#dbcef1db-83af-43f0-b2fe-153c53fc1f82~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-identifier&gt;SGroup1&lt;/sensor-group-identifier&gt;     &lt;enable&gt;&lt;/enable&gt;     &lt;sensor-paths&gt;      &lt;sensor-path&gt;       &lt;telemetry-sensor-path&gt;Cisco-IOS-XR-wdsysmon-fd-oper#system-monitoring&lt;/telemetry-sensor-path&gt;      &lt;/sensor-path&gt;      &lt;sensor-path&gt;       &lt;telemetry-sensor-path&gt;Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters&lt;/telemetry-sensor-path&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;  &lt;/telemetry-model-driven&gt; &lt;/data&gt;&lt;/rpc-reply&gt;Now let’s add an IPv6 destination to DGroup1 using gRPC dial-out and self-describing GPB encoding. You can do that with the following NETCONF operation#edit_data = '''&lt;config&gt;&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;destination-groups&gt;    &lt;destination-group&gt;     &lt;destination-id&gt;DGroup1&lt;/destination-id&gt;     &lt;destinations&gt;      &lt;destination&gt;       &lt;address-family&gt;ipv6&lt;/address-family&gt;       &lt;ipv6&gt;        &lt;ipv6-address&gt;2001#db8#0#100##b&lt;/ipv6-address&gt;        &lt;destination-port&gt;5432&lt;/destination-port&gt;        &lt;encoding&gt;self-describing-gpb&lt;/encoding&gt;        &lt;protocol&gt;         &lt;protocol&gt;grpc&lt;/protocol&gt;         &lt;tls-hostname&gt;&lt;/tls-hostname&gt;         &lt;no-tls&gt;0&lt;/no-tls&gt;        &lt;/protocol&gt;       &lt;/ipv6&gt;      &lt;/destination&gt;     &lt;/destinations&gt;    &lt;/destination-group&gt;   &lt;/destination-groups&gt;  &lt;/telemetry-model-driven&gt;&lt;/config&gt;'''xr.edit_config(edit_data, target='candidate', format='xml')xr.commit()If we do a get-config operation again, this time filtering on just the destination group#xr_filter = '''&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;&lt;destination-groups&gt;'''c = xr.get_config(source='running', filter=('subtree', xr_filter))print(c)… we’ll see that DGroup1 has the new destination.Script Output#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#d3b9beaa-9b69-4f5c-a7a8-5d3dc106ce0f~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;destination-groups&gt;    &lt;destination-group&gt;     &lt;destination-id&gt;DGroup1&lt;/destination-id&gt;     &lt;destinations&gt;      &lt;destination&gt;       &lt;address-family&gt;ipv4&lt;/address-family&gt;       &lt;ipv4&gt;        &lt;ipv4-address&gt;172.30.8.4&lt;/ipv4-address&gt;        &lt;destination-port&gt;5432&lt;/destination-port&gt;        &lt;encoding&gt;self-describing-gpb&lt;/encoding&gt;        &lt;protocol&gt;         &lt;protocol&gt;tcp&lt;/protocol&gt;         &lt;tls-hostname&gt;&lt;/tls-hostname&gt;         &lt;no-tls&gt;0&lt;/no-tls&gt;        &lt;/protocol&gt;       &lt;/ipv4&gt;      &lt;/destination&gt;      &lt;destination&gt;       &lt;address-family&gt;ipv6&lt;/address-family&gt;       &lt;ipv6&gt;        &lt;ipv6-address&gt;2001#db8#0#100##b&lt;/ipv6-address&gt;        &lt;destination-port&gt;5432&lt;/destination-port&gt;        &lt;encoding&gt;self-describing-gpb&lt;/encoding&gt;        &lt;protocol&gt;         &lt;protocol&gt;grpc&lt;/protocol&gt;         &lt;tls-hostname&gt;&lt;/tls-hostname&gt;         &lt;no-tls&gt;0&lt;/no-tls&gt;        &lt;/protocol&gt;       &lt;/ipv6&gt;      &lt;/destination&gt;     &lt;/destinations&gt;    &lt;/destination-group&gt;   &lt;/destination-groups&gt;  &lt;/telemetry-model-driven&gt; &lt;/data&gt;&lt;/rpc-reply&gt;And if you need some CLI to reassure yourself that it worked, here it is#CLI Output#RP/0/RP0/CPU0#SunC#show run telemetry model-driventelemetry model-driven destination-group DGroup1  address family ipv4 172.30.8.4 port 5432   encoding self-describing-gpb   protocol tcp  !  address family ipv6 2001#db8#0#100##b port 5432   encoding self-describing-gpb   protocol grpc  ! ! sensor-group SGroup1  sensor-path Cisco-IOS-XR-wdsysmon-fd-oper#system-monitoring  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters ! subscription Sub1  sensor-group-id SGroup1 sample-interval 30000  destination-id DGroup1Clean-up TimeSince it’s always a good idea to be able to remove what you configure, here’s the XML instantiation of the YANG model to do that using the “remove” operation.  There are other ways to do this, but this is the most surgical.edit_data = '''&lt;config&gt;&lt;telemetry-model-driven xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-telemetry-model-driven-cfg~&gt;   &lt;sensor-groups&gt;    &lt;sensor-group&gt;     &lt;sensor-group-identifier&gt;SGroup1&lt;/sensor-group-identifier&gt;     &lt;enable&gt;&lt;/enable&gt;     &lt;sensor-paths&gt;      &lt;sensor-path nc#operation=~remove~&gt;       &lt;telemetry-sensor-path &gt;Cisco-IOS-XR-wdsysmon-fd-oper#system-monitoring&lt;/telemetry-sensor-path&gt;      &lt;/sensor-path&gt;     &lt;/sensor-paths&gt;    &lt;/sensor-group&gt;   &lt;/sensor-groups&gt;  &lt;destination-groups&gt;    &lt;destination-group&gt;     &lt;destination-id&gt;DGroup1&lt;/destination-id&gt;     &lt;destinations&gt;      &lt;destination &gt;       &lt;address-family&gt;ipv6&lt;/address-family&gt;       &lt;ipv6 nc#operation=~delete~&gt;        &lt;ipv6-address&gt;2001#db8#0#100##b&lt;/ipv6-address&gt;        &lt;destination-port&gt;5432&lt;/destination-port&gt;        &lt;encoding&gt;self-describing-gpb&lt;/encoding&gt;        &lt;protocol&gt;         &lt;protocol&gt;tcp&lt;/protocol&gt;         &lt;tls-hostname&gt;&lt;/tls-hostname&gt;         &lt;no-tls&gt;0&lt;/no-tls&gt;        &lt;/protocol&gt;       &lt;/ipv6&gt;      &lt;/destination&gt;     &lt;/destinations&gt;    &lt;/destination-group&gt;   &lt;/destination-groups&gt;  &lt;/telemetry-model-driven&gt;  &lt;/config&gt;'''xr.edit_config(edit_data, target='candidate', format='xml')xr.commit()xr.close_session()ConclusionThe IOS XR Native telemetry YANG model exposes the full range of functionality in Model-Driven Telemetry.  The examples in this tutorial should get you started with configuring MDT in a programmatic way.ProseProseAboutDevelopersLanguageLogout",
      "url": "/tutorials/2016-08-15-configuring-mdt-for-tcp-dial-out-using-native-yang/",
      "author": "",
      "tags": "iosxr"
    }
    
    ,
  
  
    
    "tutorials-2016-10-13-using-model-driven-telemetry-mdt-for-if-mib-data": {
      "title": "Using Model-Driven Telemetry (MDT) for IF-MIB Data",
      "content": "     Using MDT for IF-MIB Data  Data from the IF-MIB          MDT Configuration for IF-MIB equivalence      OID-YANG Table        Data from the IF-MIBOne of the most commonly polled MIBs is the Interfaces MIB (IF-MIB).  Pretty much everyone needs to know how many packets and bytes were sent and received on a given interface.  So it’s not surprising that one of the first questions we get is how to get the IF-MIB data from MDT.MDT Configuration for IF-MIB equivalenceAs you can see from the table below, most of the interface statistics are in the Cisco-IOS-XR-infra-statsd-oper.yang model, with some state parameters in Cisco-IOS-XR-infra-statsd-oper.yang, and a couple SNMP-specific values in Cisco-IOS-XR-snmp-agent-oper.yang.Leaving aside the SNMP-specific parameters, here is what the sensor-path configuration in MDT would look like for the IF-MIB#RP/0/RP0/CPU0#SunC(config)#telemetry model-drivenRP/0/RP0/CPU0#SunC(config-model-driven)#sensor-group SGroup1RP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-countersRP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# sensor-path Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interfaceRP/0/RP0/CPU0#SunC(config-model-driven-snsr-grp)# commitFor the complete MDT configuration, see my configuration tutorial.With that, you should be streaming all your favorite IF-MIB data at a fraction of the cost of doing an SNMP poll.OID-YANG TableBelow is a table of the most commonly requested IF-MIB OIDs, their corresponding YANG models, containers, leafs and any usage notes.            OID      Yang-Path      YANG Leaf      Notes                  ifAlias      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      description                     ifHCInBroadcastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      broadcast-packets-received                     ifHCInMulticastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      multicast-packets-received                     ifHCInUcastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      N/A      Must be calculated# packets-received - multicast-packets-received - broadcast-packets-received              ifHCOutBroadcastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      broadcast-packets-sent                     ifHCOutMulticastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      multicast-packets-sent                     ifHCOutUcastPkts      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      N/A      Must be calculated# packets-sent - multicast-packets-sent - broadcast-packets-sent              ifIndex      Cisco-IOS-XR-snmp-agent-oper#snmp/interface-indexes/      if-index                     ifLastChange      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      last-state-transition-time      last-state-transition-time is the elapsed time since last state change while ifLastChange is the sysUpTime value of the last state change              ifOutDiscards      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      output-drops                     ifOutErrors      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      output-errors                     ifStackStatus      Cisco-IOS-XR-snmp-agent-oper/snmp/      if-stack-status                     ifAdminStatus      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      state                     ifDescr      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      interface-name                     ifHCInOctets      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      bytes-received                     ifHCOutOctets      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      bytes-sent                     ifHighSpeed      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      speed      ifHighSpeed is in Mbps, speed is in kbps              ifInErrors      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      input-errors                     ifOperStatus      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      state                     ifPhysAddress      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      address                     ifType      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      interface-type                     ifInDiscards      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      input-drops                     ifInOctets      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      bytes-received                     ifMtu      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      mtu                     ifName      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      interface-name      interface-name format is “HundredGigE0_3_0_0”              ifOutOctets      Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters      bytes-sent                     ifSpeed      Cisco-IOS-XR-pfi-im-cmd-oper#interfaces/interface-xr/interface      bandwidth             ",
      "url": "/tutorials/2016-10-13-using-model-driven-telemetry-mdt-for-if-mib-data/",
      "author": "Shelly Cadora",
      "tags": "iosxr"
    }
    
    ,
  
  
    
    "tutorials-2016-10-24-configuring-model-driven-telemetry-mdt-with-ydk-and-xr-native-yang-model": {
      "title": "Configuring Model-Driven Telemetry (MDT) with YDK and XR Native YANG model",
      "content": "     Configuring MDT with YDK + XR native YANG  Getting a complete MDT configuration with Native YANG and YDK  Tutorial goal  Connect to the router and import YDK’s libraries  Define and apply the destination group  Define and apply the sensor group  Define and apply the subcription  Clean  Conclusion  Getting a complete MDT configuration with Native YANG and YDKIn an earlier tutorial, Shelly introduces a methodology to configure MDT using YDK and the OpenConfig Telemetry YANG model.This document provides a similar tutorial, addressing a complete XR Telemetry TCP dial-out configuration using the native YANG model and YDK.I have tested the configuration in this document using the relative recent Vagrant IOS-XRv box version 6.2.1.15I.If you are looking for more information on IOS-XRv for Vagrant, you may follow Akshat tutorial IOS-XRv Vagrant Quick Start for step by step instructions.I have also used the ydk-py version 0.5.1 and after installing YDK, you can check ydk-models-cisco-ios-xr current support for XR 6.1.1 using pip list command.CLI Output#(ydk-py) vagrant@vagrant-ubuntu-trusty-64#~/yang$ pip list&lt;SNIP&gt;ydk (0.5.1)ydk-models-cisco-ios-xr (6.1.1)ydk-models-ietf (0.1.1)ydk-models-openconfig (0.1.1)If you are not familiar with IOS-XRv, follow Akshat tutorial IOS-XRv Vagrant Quick Start for step by step instructions.Tutorial goalBy the end of this tutorial, you will have implemented the following configuration using YDK on the router under testing. If you are unfamiliar with the configuration just check the following tutorial Configuring Model-Driven Telemetry (MDT)CLI Output#test_XR#show running-config telemetry model-driven Fri Oct 21 06#51#06.926 UTCtelemetry model-driven destination-group DG_Test  address family ipv4 192.168.10.3 port 5432   encoding self-describing-gpb   protocol tcp  ! ! sensor-group SG_Test  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters ! subscription 1  sensor-group-id SG_Test sample-interval 30000  destination-id DG_Test !!Connect to the router and import YDK’s librariesAs described in previous YDK tutorials, we are importing the YDK Netconf library to communicate with the router.We also import the CRUDService YDK’s library (taking care of create, read, update and delete YDK objects from the router) and the IOS_XR native YDK model.The Empty type that we import from ydk.types has a special purpose later in the document to signal with its presence, the request to activate the submitted subscription.from ydk.providers import NetconfServiceProvider from ydk.services import CRUDServicefrom ydk.types import Empty import ydk.models.cisco_ios_xr.Cisco_IOS_XR_telemetry_model_driven_cfg as xr_telemetryHOST = '192.168.10.2'PORT = 830USER = 'vagrant'PASS = 'vagrant'xr = NetconfServiceProvider(address=HOST,\tport=PORT,\tusername=USER,\tpassword=PASS,\tprotocol = 'ssh')With that, we are now connected to the router#CLI Output#RP/0/RP0/CPU0#test_XR#show netconf-yang clients Fri Oct 21 01#36#02.850 UTCNetconf clientsclient session ID|     NC version|    client connect time|        last OP time|        last OP type|    &lt;lock&gt;|       4261169968|            1.1|         0d  0h  0m 28s|                    |                    |        No|RP/0/RP0/CPU0#test_XR#Define and apply the destination groupTo access the native XR telemetry YANG model used in this tutorial (Cisco-IOS-XR-telemetry-model-driven-cfg.yang) use the YANG public repository.Explore this same repository to see the other vendors and standard model YANGs but just in case you are looking for the OpenConfig, you will have to use YANG OpenConfig repository.To explore the telemetry YANG model read directly the yang file or for example, follow a friendlier  tree that the Pyang utility generates.Note# if you have installed the YDK environment, you can use Pyang from this environment as pyang -f tree Cisco-IOS-XR-telemetry-model-driven-cfg.yangPYANG output for the destination-groups#module# Cisco-IOS-XR-telemetry-model-driven-cfg   +--rw telemetry-model-driven      &lt;SNIP&gt;      +--rw destination-groups      |  +--rw destination-group* [destination-id]      |     +--rw destinations      |     |  +--rw destination* [address-family]      |     |     +--rw address-family    Af      |     |     +--rw ipv4* [ipv4-address destination-port]      |     |     |  +--rw ipv4-address        inet#ip-address-no-zone      |     |     |  +--rw destination-port    xr#Cisco-ios-xr-port-number      |     |     |  +--rw protocol!      |     |     |  |  +--rw protocol        Proto-type      |     |     |  |  +--rw tls-hostname?   string      |     |     |  |  +--rw no-tls?         int32      |     |     |  +--rw encoding?           Encode-type      |     |     +--rw ipv6* [ipv6-address destination-port]      |     |        +--rw ipv6-address        xr#Cisco-ios-xr-string      |     |        +--rw destination-port    xr#Cisco-ios-xr-port-number      |     |        +--rw protocol!      |     |        |  +--rw protocol        Proto-type      |     |        |  +--rw tls-hostname?   string      |     |        |  +--rw no-tls?         int32      |     |        +--rw encoding?           Encode-type      |     +--rw destination-id    xr#Cisco-ios-xr-string      The current Devnet’s documentation for YDK API doesn’t include XR native telemetry YANG because it shows 0.4.1 content. I have honestly checked the syntax for my Python code accessing directly the Cisco_IOS_XR_telemetry_model_driven_cfg.py YDK model. Remember that you can use pip’s commands to find YDK’s modules Location that may vary by installation#pip list&lt;SNIP&gt;pip show ydk-models-cisco-ios-xr(ydk-py) vagrant@vagrant-ubuntu-trusty-64#~$ pip show ydk-models-cisco-ios-xr---Metadata-Version# 2.0Name# ydk-models-cisco-ios-xrVersion# 6.1.1Summary# YDK Python SDKHome-page# https#//github.com/CiscoDevNet/ydk-pyAuthor# Cisco SystemsAuthor-email# yang-dk@cisco.comInstaller# pipLicense# Apache 2.0Location# /home/vagrant/ydk-py/lib/python2.7/site-packagesRequires# paramiko, protobuf, lxml, ydk-models-openconfig, pycrypto, pyang, ydk-models-ietf, enum34, ecdsa, ncclient, ydk, TwistedClassifiers#  Development Status ## 3 - Alpha  Intended Audience ## Developers  Topic ## Software Development ## Build Tools  License ## OSI Approved ## Apache 2.0 License  Programming Language ## Python ## 2.7With the location of the python modules you can access Cisco_IOS_XR_telemetry_model_driven_cfg.pycd /home/vagrant/ydk-py/lib/python2.7/site-packagescd ydk/models/cisco_ios_xrcat Cisco_IOS_XR_telemetry_model_driven_cfg.pyThis is what the YANG model maps to YDK code for our example#dgroup=xr_telemetry.TelemetryModelDriven.DestinationGroups.DestinationGroup()dgroup.destination_id=~DG_Test~dgroup.destinations=dgroup.Destinations()new_destination=dgroup.Destinations.Destination()new_destination.address_family=xr_telemetry.AfEnum.IPV4new_ipv4=xr_telemetry.TelemetryModelDriven.DestinationGroups.DestinationGroup().Destinations().Destination().Ipv4()new_ipv4.destination_port=5432new_ipv4.ipv4_address=~192.168.10.3~new_ipv4.encoding=xr_telemetry.EncodeTypeEnum.SELF_DESCRIBING_GPBnew_ipv4.protocol=xr_telemetry.TelemetryModelDriven.DestinationGroups.DestinationGroup().Destinations().Destination().Ipv4().Protocol()new_ipv4.protocol.protocol=xr_telemetry.ProtoTypeEnum.TCPnew_destination.ipv4.append(new_ipv4)dgroup.destinations.destination.append(new_destination)Once you’ve populated the object, we can apply it to the router using the create method on the CRUDService object from YDK#rpc_service = CRUDService()rpc_service.create(xr, dgroup)And here is the expected CLI output with the destination group describing where and how to steam#CLI Output#RP/0/RP0/CPU0#test_XR#sh running-config telemetry model-driven Fri Oct 21 06#35#06.731 UTCtelemetry model-driven destination-group DG_Test  address family ipv4 192.168.10.3 port 5432   encoding self-describing-gpb   protocol tcp  ! !!Define and apply the sensor groupAs for the destination group, this is the section of the YANG model for the sensor group#PYANG output for the sensor-groups#module# Cisco-IOS-XR-telemetry-model-driven-cfg  +--rw telemetry-model-driven\t  +--rw sensor-groups      |  +--rw sensor-group* [sensor-group-identifier]      |     +--rw sensor-paths      |     |  +--rw sensor-path* [telemetry-sensor-path]      |     |     +--rw telemetry-sensor-path    string      |     +--rw enable?                    empty      |     +--rw sensor-group-identifier    xr#Cisco-ios-xr-string\t&lt;SNIP&gt;  … and the YDK code that it maps to#sgroup = xr_telemetry.TelemetryModelDriven.SensorGroups.SensorGroup()sgroup.sensor_group_identifier=~SG_Test~sgroup.sensor_paths = sgroup.SensorPaths()new_sensorpath = sgroup.SensorPaths.SensorPath()new_sensorpath.telemetry_sensor_path = 'Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters'sgroup.sensor_paths.sensor_path.append(new_sensorpath)Now we are ready to submit the sensor group object just populated with the same create method from the CRUDService object#rpc_service.create(xr, sgroup)Note# you need to initialize the rpc_service as rpc_service = CRUDService() a single time.If you remember, we have already done it when creating the destination group but if you skipped the previous step, add it before requesting to create for the sensor group.Let’s check the CLI running-configuration again. You should now find the destination (from the previous step) and sensor group just created in place#CLI Output#RP/0/RP0/CPU0#test_XR#show running-config telemetry model-driven Fri Oct 21 06#45#58.444 UTCtelemetry model-driven destination-group DG_Test  address family ipv4 192.168.10.3 port 5432   encoding self-describing-gpb   protocol tcp  ! ! sensor-group SG_Test  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters !!Define and apply the subcriptionThe final step in our configration is the subcription.PYANG output for the subcription#module# Cisco-IOS-XR-telemetry-model-driven-cfg  +--rw telemetry-model-driven\t&lt;SNIP&gt;      +--rw subscriptions      |  +--rw subscription* [subscription-identifier]      |     +--rw source-address!      |     |  +--rw address-family    Af      |     |  +--rw ip-address?       inet#ipv4-address-no-zone      |     |  +--rw ipv6-address?     string      |     +--rw sensor-profiles      |     |  +--rw sensor-profile* [sensorgroupid]      |     |     +--rw sample-interval?      uint32      |     |     +--rw heartbeat-interval?   uint32      |     |     +--rw supress-redundant?    empty      |     |     +--rw sensorgroupid         xr#Cisco-ios-xr-string      |     +--rw destination-profiles      |     |  +--rw destination-profile* [destination-id]      |     |     +--rw enable?           empty      |     |     +--rw destination-id    xr#Cisco-ios-xr-string      |     +--rw source-qos-marking?        uint32      |     +--rw subscription-identifier    xr#Cisco-ios-xr-string\t&lt;SNIP&gt;  This is how that ends up in YDK code#sub = xr_telemetry.TelemetryModelDriven.Subscriptions.Subscription()sub.subscription_identifier = ~1~sub.sensor_profiles = sub.SensorProfiles()sub.destination_profiles = sub.DestinationProfiles()                               new_sprofile = sub.SensorProfiles.SensorProfile()new_sprofile.sensorgroupid = 'SG_Test'new_sprofile.sample_interval = 30000new_dprofile = sub.DestinationProfiles.DestinationProfile()new_dprofile.destination_id=~DG_Test~new_dprofile.enable=Empty()sub.sensor_profiles.sensor_profile.append(new_sprofile)sub.destination_profiles.destination_profile.append(new_dprofile)rpc_service.create(xr, sub)If you check your router running-configuration, you should now have a complete TCP dial-out telemetry configuration  as#CLI Output#P/0/RP0/CPU0#test_XR#show running-config telemetry model-driven Fri Oct 21 06#51#06.926 UTCtelemetry model-driven destination-group DG_Test  address family ipv4 192.168.10.3 port 5432   encoding self-describing-gpb   protocol tcp  ! ! sensor-group SG_Test  sensor-path Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters ! subscription 1  sensor-group-id SG_Test sample-interval 30000  destination-id DG_Test !!CleanTwo last commands to delete the configuration just submitted and disconnect the Netconf session.rpc_service.delete(xr, xr_telemetry.TelemetryModelDriven())xr.close()And confirm in the router’s ‘show running-config’CLI Output#RP/0/RP0/CPU0#test_XR#show running-config telemetry model-driven Fri Oct 21 06#59#46.743 UTC% No such configuration item(s)RP/0/RP0/CPU0#test_XR#ConclusionThis tutorial complements the concepts explained by Shelly in her earlier tutorial. The same values in programmability using YANG models, automatic generation of Python classes that inherit the syntactic checks and requirements of the underlying model, while also handling all the details for the sensor group using the native telemetry YANG model.",
      "url": "/tutorials/2016-10-24-configuring-model-driven-telemetry-mdt-with-ydk-and-xr-native-yang-model/",
      "author": "Marco Umer",
      "tags": "iosxr, YDK, YANG, Telemetry"
    }
    
    ,
  
  
    
    "tutorials-2016-12-23-streaming-bgp-route-and-neighbor-counts-with-mdt": {
      "title": "Streaming BGP Route and Neighbor Counts with MDT",
      "content": "     Streaming BGP Stats with MDT  BGP Performance Indicators          Number of BGP Routes      Number of BGP Neighbors        BGP Performance IndicatorsThe number of BGP routes and neighbor at any given time can be good, high-level indicators of network health.  Being able to stream those numbers periodically is a good use of model-driven telemetry (MDT) but the associated YANG models are large and can be intimidating, so this tutorial shows how to drill down for these specific stats.Number of BGP RoutesFor CLI fans, the information that I was looking for is often found in the output of “show route ipv4 summary”#RP/0/RP0/CPU0#SunC#show route ipv4 summaryFri Dec 23 16#48#59.988 UTCRoute Source                     Routes     Backup     Deleted     Memory(bytes)local                            3          0          0           720connected                        2          1          0           720static                           1          0          0           240dagr                             0          0          0           0bgp 1                            5          1          0           1440isis 1                           1          1          0           480Total                            12         3          0           3600RP/0/RP0/CPU0#SunC#This data is included in the IOS XR native YANG model called “Cisco-IOS-XR-ip-rib-ipv4-oper.yang”.  Now, there is a ton of stuff in that YANG model, including all of the prefixes in the RIB.  That’s too much. I just want the summary statistics for BGP routes.  So I needed to filter down to a very specific tree path.  Using pyang to present a tree view of the model, here is the desired path#$ pyang -f tree Cisco-IOS-XR-ip-rib-ipv4-oper.yang --tree-path rib/vrfs/vrf/afs/af/safs/saf/ip-rib-route-table-names/ip-rib-route-table-name/protocol/bgp/as/informationmodule# Cisco-IOS-XR-ip-rib-ipv4-oper   +--ro rib      +--ro vrfs         +--ro vrf* [vrf-name]            +--ro afs               +--ro af* [af-name]                  +--ro safs                     +--ro saf* [saf-name]                        +--ro ip-rib-route-table-names                           +--ro ip-rib-route-table-name* [route-table-name]                              +--ro protocol                                 +--ro bgp                                    +--ro as* [as]                                       +--ro information                                          +--ro protocol-names?                string                                          +--ro instance?                      string                                          +--ro version?                       uint32                                          +--ro redistribution-client-count?   uint32                                          +--ro protocol-clients-count?        uint32                                          +--ro routes-counts?                 uint32                                          +--ro active-routes-count?           uint32                                          +--ro deleted-routes-count?          uint32                                          +--ro paths-count?                   uint32                                          +--ro protocol-route-memory?         uint32$If you did a NETCONF  operation on this subtree, the data would be returned encoded in XML like this#&lt;?xml version=~1.0~?&gt;&lt;rpc-reply message-id=~urn#uuid#7aa4d7d8-4638-40ed-bb87-93b1403e0baa~ xmlns#nc=~urn#ietf#params#xml#ns#netconf#base#1.0~ xmlns=~urn#ietf#params#xml#ns#netconf#base#1.0~&gt; &lt;data&gt;  &lt;rib xmlns=~http#//cisco.com/ns/yang/Cisco-IOS-XR-ip-rib-ipv4-oper~&gt;   &lt;vrfs&gt;    &lt;vrf&gt;     &lt;vrf-name&gt;default&lt;/vrf-name&gt;     &lt;afs&gt;      &lt;af&gt;       &lt;af-name&gt;IPv4&lt;/af-name&gt;       &lt;safs&gt;        &lt;saf&gt;         &lt;saf-name&gt;Unicast&lt;/saf-name&gt;         &lt;ip-rib-route-table-names&gt;          &lt;ip-rib-route-table-name&gt;           &lt;route-table-name&gt;default&lt;/route-table-name&gt;           &lt;protocol&gt;            &lt;bgp&gt;             &lt;as&gt;              &lt;as&gt;1&lt;/as&gt;              &lt;information&gt;               &lt;protocol-names&gt;bgp&lt;/protocol-names&gt;               &lt;instance&gt;1&lt;/instance&gt;               &lt;version&gt;0&lt;/version&gt;               &lt;redistribution-client-count&gt;0&lt;/redistribution-client-count&gt;               &lt;protocol-clients-count&gt;1&lt;/protocol-clients-count&gt;               &lt;routes-counts&gt;6&lt;/routes-counts&gt;               &lt;active-routes-count&gt;5&lt;/active-routes-count&gt;               &lt;deleted-routes-count&gt;0&lt;/deleted-routes-count&gt;               &lt;paths-count&gt;6&lt;/paths-count&gt;               &lt;protocol-route-memory&gt;1440&lt;/protocol-route-memory&gt;               &lt;backup-routes-count&gt;1&lt;/backup-routes-count&gt;              &lt;/information&gt;             &lt;/as&gt;            &lt;/bgp&gt;           &lt;/protocol&gt;          &lt;/ip-rib-route-table-name&gt;         &lt;/ip-rib-route-table-names&gt;        &lt;/saf&gt;       &lt;/safs&gt;      &lt;/af&gt;     &lt;/afs&gt;    &lt;/vrf&gt;   &lt;/vrfs&gt;  &lt;/rib&gt; &lt;/data&gt;&lt;/rpc-reply&gt;To get this same data encoded in Google Protocol Buffers and streamed using MDT, just configure a sensor-path as follows#telemetry model-driven  sensor-group SGroup1   sensor-path Cisco-IOS-XR-ip-rib-ipv4-oper#rib/vrfs/vrf/afs/af/safs/saf/ip-rib-route-table-names/ip-rib-route-table-name/protocol/bgp/as/informationNotice that the subtree filter (everything after Cisco-IOS-XR-ip-rib-ipv4-oper# in the sensor-path) is exactly the same as the argument I passed to the –tree-path filter in pyang.  That’s a handy tip for constructing sensor-paths in general!Number of BGP NeighborsFor BGP neighbor counts, the model you want is Cisco-IOS-XR-ipv4-bgp-oper.yang.  Again, this is a very juicy model, so it’s best to winnow it down to the nearest subtree#$ pyang -f tree Cisco-IOS-XR-ipv4-bgp-oper.yang --tree-path bgp/instances/instance/instance-active/default-vrf/process-info/globalmodule# Cisco-IOS-XR-ipv4-bgp-oper   +--ro bgp      +--ro instances         +--ro instance* [instance-name]            +--ro instance-active               +--ro default-vrf                  +--ro process-info                     +--ro global                        +--ro process-instance-node?                string                        +--ro restart-count?                        uint32                        +--ro path-attributes-entry-count?          uint32                        +--ro path-attribute-memory?                uint32                        +--ro as-path-entry-count?                  uint32                        +--ro as-path-entries-memory?               uint32                        +--ro community-entry-count?                uint32                        +--ro community-memory?                     uint32                        +--ro extended-community-entry-count?       uint32                        +--ro extended-community-memory?            uint32                        +--ro pe-distinguisher-label-entry-count?   uint32                        +--ro pe-distinguisher-label-memory?        uint32                        +--ro pta-entry-count?                      uint32                        +--ro pta-memory?                           uint32                        +--ro ribrnh-entry-count?                   uint32                        +--ro ribrnh-memory?                        uint32                        +--ro ppmp-entry-count?                     uint32                        +--ro ppmp-memory?                          uint32                        +--ro route-reflectors?                     uint32                        +--ro route-reflector-memory?               uint32                        +--ro nexthop-count?                        uint32                        +--ro nexthop-memory?                       uint32                        +--ro local-as?                             uint32                        +--ro total-vrf-count?                      uint32                        +--ro neighbors-count-total?                uint32                        +--ro established-neighbors-count-total?    uint32                        +--ro sn-num-non-dflt-vrf-nbrs?             uint32                        +--ro sn-num-non-dflt-vrf-nbrs-estab?       uint32                        +--ro pool-size*                            uint32                        +--ro pool-alloc-count*                     uint32                        +--ro pool-free-count*                      uint32                        +--ro msg-log-pool-size*                    uint32                        +--ro msg-log-pool-alloc-count*             uint32                        +--ro msg-log-pool-free-count*              uint32Depending on whether you’re interested in all neighbors or just neighbors in the established state, you can grab neighbors-count-total or established-neighbors-count-total from that list.To get that data via MDT,  configure the sensor path like this#telemetry model-driven  sensor-group SGroup1   sensor-path Cisco-IOS-XR-ipv4-bgp-oper#bgp/instances/instance/instance-active/default-vrf/process-infoThe hardest part of MDT is often just figuring out which YANG model and subtree has the data you need.  Once you’ve got that, the configuration is pretty trivial.  Hopefully these two examples will get you started.",
      "url": "/tutorials/2016-12-23-streaming-bgp-route-and-neighbor-counts-with-mdt/",
      "author": "Shelly Cadora",
      "tags": "iosxr, bgp, yang, mdt, telemetry"
    }
    
    ,
  
  
    
    "tutorials-2016-10-03-pipeline-to-text-tutorial": {
      "title": "Using Pipeline: TCP to textfile",
      "content": "     Using Pipeline  Using Pipeline          Preparing the Router      Getting Pipeline      Pipeline.conf      Configuring the Input Stage for TCP Dial-Out      Configuring the Output Stage for Text File      Running Pipeline      Seeing the Data      Why Did We Do That Again?        Using PipelineIn an earlier blog, I introduced Pipeline, a multi-function telemetry collection service written in Go.  In this tutorial, I’ll cover how to set up Pipeline for the simplest of tasks#  ingesting telemetry data over TCP and writing it to a file as a JSON object.Preparing the RouterThis tutorial assumes that you’ve already configured your router for model-driven telemetry (MDT) with TCP dial-out using the instructions in this tutorial. The IP address and port that you specify in the destination-group in the router config should match the IP address and port on which Pipeline is listening.Getting PipelinePipeline is available from github.Pipeline.confThe pipeline.conf file contains all the configuration necessary to get Pipeline running.  In many cases, the default pipeline.conf can be used with little or no modification.The pipeline configuration is divided up into sections.  Each section is delineated by an arbitrary name enclosed in square brackets.  Each section defines either an input stage (“stage = xport_input”) or an output stage (“stage = export_output”).  Other parameters in the section tell Pipeline what to listen for (in the case of an input stage) or how to output the data (for an output stage).The easiest way to understand this is to look at a simple example.Configuring the Input Stage for TCP Dial-OutLet’s take a look at the TCP dial-out section in the default pipeline.conf.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ grep -A20 ~Example of a TCP dialout~ pipeline.conf# Example of a TCP dialout (router connects to pipeline over TCP)#[testbed]stage = xport_input## Module type, the type dictates the rest of the options in the section.# TCP can only be used as xport_iinput currently. UDP works similarly.#type = tcp## Supported encapsulation is 'st' for streaming telemetry header. This# is the header used to carry streaming telemetry payload in TCP and UDP.#encap = st## TCP option dictating which binding to listen on. Can be a host name# or address and port, or just port.#listen = #5432This [testbed] section shown above will work “as is” for MDT with TCP dial-out.  If you want to change the port that Pipeline listens on to something other than “5432”, you can edit this section of the pipeline.conf.  Otherwise, we’re good to go for the input stage.Configuring the Output Stage for Text FileTo dump the received data to a file, we need a “tap” stage in Pipeline.  The default pipeline.conf file comes with a tap stage section called [inspector] as you can see below.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ grep -A20 ~Example of a tap stage~ pipeline.conf# Example of a tap stage; dump content to file, or at least count messages#[inspector]stage = xport_output## Module type# tap is only supported in xport_output stage currently.#type = tap## File to dump decoded messages#file = /data/dump.txt## encoding = json#This [inspector] section shown above will work “as is” for dumping data to a file.  If you want to change the file that Pipeline writes to (default is /data/dump.txt) or write with a different encoding (default is JSON), you can edit this section of the pipeline.conf.  Otherwise, we’re good to go for the output stage as well.Running PipelineRunning pipeline is trivial.  Just execute the binary in the bin directory.  Pipeline will use the pipeline.conf file by default.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ bin/pipeline &amp;[1] 21975scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ Startup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]Wait for ^C to shutdownscadora@darcy#~/bigmuddy-network-telemetry-pipeline$Seeing the DataAssuming your router is properly configured, the router should initiate the TCP session to Pipeline and stream the data specified in the sensor-group configuration.  To see the data as it comes in, use the Linux “tail” utility on the file that the [inspector] stage was configured to write to.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ tail -f dump.txt------- 2017-04-03 20#37#06.763244782 -0700 PDT -------Summary# GPB(common) Message [172.30.8.53#15457(SunC)/Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters msg len# 5984]{    ~Source~# ~172.30.8.53#15457~,    ~Telemetry~# {        ~node_id_str~# ~SunC~,        ~subscription_id_str~# ~Sub1~,        ~encoding_path~# ~Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters~,        ~collection_id~# 712163,        ~collection_start_time~# 1491277026499,        ~msg_timestamp~# 1491277026499,        ~collection_end_time~# 1491277026507    },    ~Rows~# [        {               ~Timestamp~# 1491277026506,            ~Keys~# {                ~interface-name~# ~MgmtEth0/RP0/CPU0/0~            },            ~Content~# {                ~applique~# 0,                ~availability-flag~# 0,                ~broadcast-packets-received~# 65679,                ~broadcast-packets-sent~# 0,                ~bytes-received~# 272894774,                ~bytes-sent~# 20829696017,                ~carrier-transitions~# 1,                &lt;output snipped for brevity&gt;Why Did We Do That Again?To leverage the real power of telemetry, you need to get the data into an analytics stack like InfluxDB or Prometheus…or to multiple consumers via a pub/sub mechanism like Kafka.  Pipeline can do all that and I’ll show you how in future tutorials.But having the power to dump encoded telemetry data into a text file does come in handy, especially when you’re setting up telemetry and Pipeline for the first time.  The tap output module gives you a quick and easy way to validate that the router is sending the data you think it should be sending.  Once that’s settled, it’s a simple matter of configuring a different output module to send the data some place really useful.Give Pipeline a try and let us know what you think!",
      "url": "/tutorials/2016-10-03-pipeline-to-text-tutorial/",
      "author": "Shelly Cadora",
      "tags": "iosxr, MDT, telemetry, pipeline"
    }
    
    ,
  
  
    
    "tutorials-2017-04-10-using-pipeline-integrating-with-influxdb": {
      "title": "Using Pipeline: Integrating with InfluxDB",
      "content": "     Integrating Pipeline with InfluxDB  Using Pipeline          Preparing the Router      Getting Influxdb      Getting Pipeline      Pipeline.conf      Running Pipeline      Seeing the Data Before It Goes To InfluxDB      InfluxDB      Conclusion        Using PipelineIn an earlier blog, I discussed how to configure Pipeline to write Model-Driven-Telemetry (MDT) data to a plain text file. In this tutorial, I’ll describe the Pipeline configuration that enables you to write telemetry data into InfluxDB, an open source platform for time-series data.Here’s a picture of what we are trying to do#Pipeline and InfluxDB can run on the same server or on different servers, as long as there is connectivity between them.Preparing the RouterThis tutorial assumes that you’ve already configured your router for model-driven telemetry (MDT) with TCP dial-out using the instructions in this tutorial. The IP address and port that you specify in the destination-group in the router config should match the IP address and port on which Pipeline is listening.Getting InfluxdbThis tutorial assumes that you have a working instance of InfluxDB with an IP address that is accessible from your Pipeline instance and has a database named “mdt_db”.   If you want to use a different database name, edit the pipeline.conf output stage configuration below.InfluxDB is available from github and includes documentation on creating databases.  InfluxDB is also available as a Docker container.Getting PipelinePipeline is available from github.Pipeline.confConfiguring the Input Stage for TCP Dial-OutFor this tutorial, I’ll use the default pipeline.conf input stage for MDT TCP Dial-Out described in the TCP to Textfile tutorial.  If you take out all the comments, this reduces to 5 lines in pipeline.conf#[testbed]stage = xport_inputtype = tcpencap = stlisten = #5432This [testbed] section shown above will work “as is” for MDT with TCP dial-out.  If you want to change the port that Pipeline listens on to something other than “5432”, you can edit this section of the pipeline.conf.  Otherwise, we’re good to go for the input stage.Configuring the Output Stage for InfluxDBTo push the data to InfluxDB, we need a “metrics” output stage in Pipeline.  The default pipeline.conf file comes with an example metrics stage section called [mymetrics].  Taking out the comments, the important lines are as follows#[mymetrics]stage = xport_outputtype = metricsfile = metrics.jsondump = metricsdump.txtoutput = influxinflux = http#//10.152.176.74#8086database = mdt_dbThis configuration instructs Pipeline to post MDT data to an InfluxDB instance at 10.152.176.74#8086 that has a database named mdt_db.Before posting the data to influxdb, pipeline transforms the data according to the instructions in the metrics.json file.  More on this in the next section.Finally, the dump = metricsdump.txt option lets you locally dump a copy of the same data that is being pushed to influxdb.  This is useful for first-time setup and debugging.Using metrics.jsonTL;DR If you are using the sensor-path from the TCP to Textfile tutorial and the default metrics.json, you actually have nothing to do.  But if you have a burning desire to know how things works, please read the rest of the section!YANG models define data hierarchies.  Because MDT is based on YANG models, the raw telemetry data from a router is also hierarchical.  Time-series databases, however, typically expect data in a simple format# metric name, metric value, timestamp and, optionally, some tags or keys.  In influxdb, this format is called the “Line Protocol.”One of the important functions of Pipeline is to take the hierarchical YANG-based data and transform it into the Line Protocol for easy consumption by influxdb.  Pipeline takes the complex, hierarchical YANG-modeled data and flattens it into multiple time series.  Pipeline uses the metrics.json file to perform the transformation. The metrics.json file contains a series of json objects, one for each YANG model and sub-tree path that the router streams.Take the sensor-path configured on the router in the TCP Dial Out Tutorial# Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters.  The corresponding object in the default metrics.json is below#{\t\t~basepath~ # ~Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters~,\t\t~spec~ # {\t\t\t~fields~ # [\t\t\t\t{~name~ # ~interface-name~, ~tag~ # true},\t\t\t\t{~name~ # ~packets-received~},\t\t\t\t{~name~ # ~bytes-received~},\t\t\t\t{~name~ # ~packets-sent~},\t\t\t\t{~name~ # ~bytes-sent~},\t\t\t\t{~name~ # ~output-drops~},\t\t\t\t{~name~ # ~output-queue-drops~},\t\t\t\t{~name~ # ~input-drops~},\t\t\t\t{~name~ # ~input-queue-drops~},\t\t\t\t{~name~ # ~input-errors~},\t\t\t\t{~name~ # ~crc-errors~},\t\t\t\t{~name~ # ~input-ignored-packets~},\t\t\t\t{~name~ # ~output-errors~},\t\t\t\t{~name~ # ~output-buffer-failures~},\t\t\t\t{~name~ # ~carrier-transitions~}\t\t\t]\t\t}\t}This entry in the metrics.json file enables Pipeline to post interface statistics in the influxdb Line Protocol with the following characteristics#Measurement# - Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-countersTag Names and Values- EncodingPath=Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counter- Producer=SunC- interface-name=MgmtEth0/RP0/CPU0/0Field Keys and Values- bytes-received=307428735- bytes-sent=23017070265- Timestamp- 1491942788950000000You might have noticed that “interface-name” is one of the Tag Names, not a Field Key above. There are two ways to get an MDT metric marked as a Tag.  First, recall that the router sends MDT data as one of two types# Keys and Content.  Pipeline will automatically translate items in the MDT Keys section to a Tag.  You can also use the metrics.json file.  Any entry in the metrics.json file with ~tag~ # true will be added to the Tag Names in the Line Protocol and not sent as a Field Key.Also good to know# if you don’t have an entry in the metrics.json file, then that data point will not be posted to InfluxDB, even if the router sends that data to Pipeline.  That’s actually a feature!  Because bulk data collection is more efficient for the router, the router streams data at the container level of the YANG model.  That means you will sometimes receive more data than you actually need.  Pipeline gives you the ability to filter what data gets passed on to your time series database.Final takeaway, if the path you are streaming is already described in the metrics.json and has all the fields you care about (as is this case here), there is nothing to do.  Adding objects to the metrics.json will be the topic of a future tutorial.Running PipelineRun pipeline as usual, by executing the binary in the bin directory. Pipeline will use the pipeline.conf file by default.  Pipeline will prompt you for credentials to use when posting to influxdb.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ bin/pipelineStartup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]CRYPT Client [mymetrics],[http#//10.152.176.84#8086] Enter username# admin Enter password#Wait for ^C to shutdownPower users will appreciate the -log= -debug option for pipeline#scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ bin/pipeline -log= -debugINFO[2017-04-12 14#41#05.038501] Conductor says hello, loading config          config=pipeline.conf debug=true fluentd= logfile= maxthreads=1 tag=pipeline version=~v1.0.0(bigmuddy)~DEBU[2017-04-12 14#41#05.039562] Conductor processing section...               name=conductor section=inspector tag=pipelineDEBU[2017-04-12 14#41#05.039690] Conductor processing section, type...         name=conductor section=inspector tag=pipeline type=tapINFO[2017-04-12 14#41#05.039800] Conductor starting up section                 name=conductor section=inspector stage=~xport_output~ tag=pipelineDEBU[2017-04-12 14#41#05.039887] Conductor processing section...               name=conductor section=mymetrics tag=pipelineDEBU[2017-04-12 14#41#05.039940] Conductor processing section, type...         name=conductor section=mymetrics tag=pipeline type=metricsINFO[2017-04-12 14#41#05.039982] Conductor starting up section                 name=conductor section=mymetrics stage=~xport_output~ tag=pipeline&lt;output snipped for brevity&gt;Seeing the Data Before It Goes To InfluxDBSince we configure a “dump” file in the [mymetrics] output stage above, Pipeline will dump a local copy of the data it posts to InfluxDB into a text file in the Line Protocol format.  This is a good way to confirm that Pipeline is receiving data from the router and parsing it with a valid metrics.json entry.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ tail -f metricsdump.txt_wkid0Server# [http#//10.152.176.84#8086], wkid 0, writing 7 points in db# mdt_db(prec# [ms], consistency# [], retention# [])\tCisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,EncodingPath=Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,Producer=SunC,interface-name=Bundle-Ether1 bytes-received=175069849,bytes-sent=9057828,carrier-transitions=0i,crc-errors=0i,input-drops=0i,input-errors=0i,input-ignored-packets=0i,input-queue-drops=0i,output-buffer-failures=0i,output-drops=0i,output-errors=0i,output-queue-drops=0i,packets-received=1189543,packets-sent=103020 1491943978355000000\tCisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,EncodingPath=Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,Producer=SunC,interface-name=Null0 bytes-received=0,bytes-sent=0,carrier-transitions=0i,crc-errors=0i,input-drops=0i,input-errors=0i,input-ignored-packets=0i,input-queue-drops=0i,output-buffer-failures=0i,output-drops=0i,output-errors=0i,output-queue-drops=0i,packets-received=0,packets-sent=0 1491943978355000000\tCisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,EncodingPath=Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters,Producer=SunC,interface-name=MgmtEth0/RP0/CPU0/0 bytes-received=307431285,bytes-sent=23017071885,carrier-transitions=1i,crc-errors=0i,input-drops=139i,input-errors=0i,input-ignored-packets=0i,input-queue-drops=0i,output-buffer-failures=0i,output-drops=0i,output-errors=0i,output-queue-drops=0i,packets-received=4338703,packets-sent=16808000 1491943978355000000InfluxDBTo validate that the data has been received by influxdb, you can use curl to query the database#$ curl -G 'http#//localhost#8086/query?pretty=true' --data-urlencode ~db=mdt_db~ --data-urlencode ~q=SELECT \\~bytes-sent\\~ FROM \\~Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters\\~ WHERE \\~interface-name\\~='GigabitEthernet0/0/0/0'~{    ~results~# [        {            ~series~# [                {                    ~name~# ~Cisco-IOS-XR-infra-statsd-oper#infra-statistics/interfaces/interface/latest/generic-counters~,                    ~columns~# [                        ~time~,                        ~bytes-sent~                    ],                    ~values~# [                        [                            ~2017-04-11T21#04#57.205Z~,                            1.911903356e+09                        ],                        [                            ~2017-04-11T21#05#27.214Z~,                            1.911903356e+09                        ],                        [                            ~2017-04-11T21#05#57.226Z~,                            1.911911181e+09                        ]                    ]                }            ]        }    ]}If you are using grafana to query and visualize your influxdb data, you can use all the queries and dashboards you know and love, as in this simple graph of packets sent on Gigabit Ethernet 0/0/0/0#For those hearty souls who slogged through the Using metrics.json section, note that we could use interface-name in the Where clause of the query above because it was sent as a Tag in the Line Protocol.ConclusionPipeline gives you a easy, flexible way to get data into commonly used open-source tools like influxdb.  Give it a try and let us know what you think!",
      "url": "/tutorials/2017-04-10-using-pipeline-integrating-with-influxdb/",
      "author": "Shelly Cadora",
      "tags": "iosxr, telemetry, MDT, pipeline"
    }
    
    ,
  
  
    
    "tutorials-2017-05-05-mdt-with-grpc-transport-tricks": {
      "title": "MDT with gRPC: Transport Tricks",
      "content": "     MDT with gRPC# Transport Tricks  gRPC  What is gRPC again?  What Does gRPC see?  Just Tell Me How to Fix It  I Didn’t Configure TPA But It Still Works, So There!  Conclusion  gRPCIn previous tutorials, I’ve covered how to configure a router for Model-Driven Telemetry (MDT) with gRPC dial-out and dial-in.  In this tutorial, I’ll discuss some advanced topics and gotchas that you might encounter as you work with gRPC.Note that you may not need to read this blog!  It is entirely likely that your gRPC connection will “just work.”  But for the few corner cases where it doesn’t, you might have to read this.  For example, if you can get TCP dial-out to work but not gRPC dial-out, keep reading…What is gRPC again?gRPC is an open source RPC framework that leverages HTTP/2 as a transport.  Compared to simple TCP transport, gRPC brings two important features to MDT# 1) Optional encryption with TLS and 2) Support for “dial-in” (from collector to router).Now bear with me for a moment, as this next bit get a little complicated.  If you are familiar with the 64 bit IOS XR software architecture, you may already be aware that IOS XR runs in a container on top of a Linux kernel.  The gRPC server used by MDT lives in the IOS XR container (it’s part of the IOS XR Linux shell) but it is not part of the XR Control Plane proper.  This means that gRPC uses the Linux networking stack (not the XR networking stack).  And this is where problems can happen.What Does gRPC see?To see the world from gRPC’s perspective, drop into the XR Linux shell and take a look at the routes there#RP/0/RP0/CPU0#SunC#bashFri May  5 21#22#04.749 UTC[xr-vm_node0_RP0_CPU0#~]$netstat -rKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window  irtt Iface10.30.111.0     *               255.255.255.0   U         0 0          0 Mg0_RP0_CPU0_0[xr-vm_node0_RP0_CPU0#~]$From this output, you can see that there is only a single route out the management interface.  If your gRPC collector lives on that subnet, the gRPC process will be able to find it.  So that’s one reason some lucky people don’t have to read this blog.  But if your collector is reachable through some other port, gRPC doesn’t know how to get there.  One symptom is that your subscription will stay in the dreaded “Not Active” state#RP/0/RP0/CPU0#SunC#show telem model destination DGroup1 | include StateFri May  5 22#16#48.995 UTC    State#                Not ActiveIf you are doing gRPC dial-out, you will see this trace#RP/0/RP0/CPU0#SunC#show grpc trace emsFri May  5 21#36#58.868 UTCMay  5 21#36#57.774 ems/grpc 0/RP0/CPU0 t19523 EMS-GRPC# grpc# Conn.resetTransport failed to create client transport# connection error# desc = ~transport# dial tcp 172.30.8.4#5432# connect# network is unreachable~; Reconnecting to ~172.30.8.4#5432~May  5 21#38#01.626 ems/grpc 0/RP0/CPU0 t13628 EMS-GRPC# Failed to dial 172.30.8.4#5432# grpc# timed out trying to connect; please retry.RP/0/RP0/CPU0#SunC#Just Tell Me How to Fix ItOne way to fix this for both dial-in and dial-out is by configuring a Third-Party App (TPA) source address.  Configuring the TPA sets a src-hint for Linux applications, so that originating traffic from the applications can be tied to any reachable IP of XR.RP/0/RP0/CPU0#SunC(config)#tpa address-family ipv4 update-source GigabitEthernet 0/0/0/0By doing this, we automatically get a default route in the Linux shell (the fwdintf takes the traffic back to XR for routing)#[xr-vm_node0_RP0_CPU0#~]$netstat -rKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window  irtt Ifacedefault         *               0.0.0.0         U         0 0          0 fwdintf10.30.111.0     *               255.255.255.0   U         0 0          0 Mg0_RP0_CPU0_0[xr-vm_node0_RP0_CPU0#~]$So now, gRPC has a route back to the collector.  That’s all you need for dial-in.For dial-out, gRPC now knows to use GigabitEthernet0/0/0/0 as a source address. You can see that here#[xr-vm_node0_RP0_CPU0#~]$ip routedefault dev fwdintf  scope link  src 172.30.8.5310.30.111.0/24 dev Mg0_RP0_CPU0_0  proto kernel  scope link  src 10.30.111.9[xr-vm_node0_RP0_CPU0#~]$See that “src 172.30.8.53” ?  That’s the source address that gRPC will use when sending MDT traffic in dial-out mode.Note that you can use any operational interface for the update-source, with the exception of dot1q-tagged VLAN sub-interfaces (as of IOS XR 6.2).  If you’ve used update-source in other contexts (e.g. BGP neighbors configs), then you know that using a Loopback address is typically preferred since Loopbacks never goes down.  Just make sure that the Loopback you specify is return-path-routable from your collector!And speaking of Loopbacks…I Didn’t Configure TPA But It Still Works, So There!So some lucky people who didn’t configure TPA can still get gRPC to work!  Doesn’t seem fair, does it?  Well, the reason is that they have a Loopback (any Loopback except Loopback 1 which is reserved – gory detail fans read this).  When a Loopback interface is configured, you also get a default route in the Linux stack#RP/0/RP0/CPU0#SunC(config)#no tpaRP/0/RP0/CPU0#SunC(config)#int loop0RP/0/RP0/CPU0#SunC(config-if)#ipv4 address 5.5.5.5/32RP/0/RP0/CPU0#SunC(config-if)#commitRP/0/RP0/CPU0#SunC(config-if)#endRP/0/RP0/CPU0#SunC#bashFri May  5 22#01#59.141 UTC[xr-vm_node0_RP0_CPU0#~]$netstat -rKernel IP routing tableDestination     Gateway         Genmask         Flags   MSS Window  irtt Ifacedefault         *               0.0.0.0         U         0 0          0 fwdintf10.30.111.0     *               255.255.255.0   U         0 0          0 Mg0_RP0_CPU0_0That’s good for dial-in, but what about dial-out?  Well, it still might work. Check out the src address below#[xr-vm_node0_RP0_CPU0#~]$ip routedefault dev fwdintf  scope link  src 5.5.5.510.30.111.0/24 dev Mg0_RP0_CPU0_0  proto kernel  scope link  src 10.30.111.9[xr-vm_node0_RP0_CPU0#~]$Traffic sent to the collector will have a source address of 5.5.5.5.  If your collector has a route back to 5.5.5.5 (e.g. you’re distributing your loopback addresses in your IGP), then great.  If not, then the collector will drop the packet and you’ll need the TPA config for an interface IP address that is routable from the collector.ConclusionI hope you didn’t have to read this tutorial at all.  But if you did and even if you glazed over the bits about the Linux networking stack and XR Linux shell, just remember this# to make gRPC work, use a routable Loopback or TPA update-source.",
      "url": "/tutorials/2017-05-05-mdt-with-grpc-transport-tricks/",
      "author": "Shelly Cadora",
      "tags": "iosxr, MDT, Telemetry, gRPC"
    }
    
    ,
  
  
    
    "tutorials-2017-05-08-pipeline-with-grpc": {
      "title": "Pipeline with gRPC",
      "content": "     Pipeline with gRPC  Introduction  gRPC Dialout          gRPC Dialout Without TLS                  Router Config# no-tls          Pipeline.conf# tls = false                    gRPC Dialout With TLS                  Certificates for TLS Dialout          Configuring the Router for gRPC Dialout with TLS          Configuring Pipeline for tls=true                      gRPC Dialin          Common Router Config for gRPC DialIn      Common Dialin Credentials                  gRPC Dialin Without TLS          gRPC Dialin With TLS          Appendix# Secure Password Storage for Dialin                      IntroductionIn previous tutorials, I’ve shown how to use Pipeline to dump Model Driven Telemetry (MDT) data into a text file and into InfluxDB.  In each case, I configured the router to transport MDT data to Pipeline using TCP.  In this tutorial, I’ll cover a few additional steps that are required to use Pipeline with gRPC.  I’ll focus on only the changes needed in the router and Pipeline input stage configs here, so be sure to consult the other Pipeline tutorials for important info about install, output stage, etc.If you’re going to use gRPC, the first thing to decide is whether you’re going to dial out from the router or dial in to the router.If you don’t know the difference between dialin and dialout or need help chosing, check out my blog for some guidance.Once you’ve made that decision, go the appropriate section of this tutorial# gRPC Dialout or gRPC Dialin.  For each section, there will be some “common” router and Pipeline config setps and well as some specific steps you need depending on whether or not you enable TLS.gRPC DialoutFor gRPC Dialout, the subscription and sensor-group config are the same whether you use TLS or not, so I’ll re-use those parts of the MDT router config from the gRPC dialout example.  It will look like this#telemetry model-driven sensor-group SGroup2  sensor-path Cisco-IOS-XR-nto-misc-oper#memory-summary/nodes/node/summary ! subscription Sub2  sensor-group-id SGroup2 sample-interval 30000  destination-id DGroup2Now the big decision is whether to use TLS or not. This impacts the destination-group in the router config and the ingress stage of the Pipeline input stage as you’ll see below.gRPC Dialout Without TLSIf you don’t use TLS, your MDT data won’t be encrypted.  On the other hand, it’s easy to configure. So if you’re new to MDT and gRPC, this might be a good starting place.Router Config# no-tlsThe gRPC config for the router is contained in the MDT destination-group.  Here is a destination-group for gRPC dialout without TLS#telemetry model-driven destination-group DGroup2  address family ipv4 172.30.8.4 port 57500   encoding self-describing-gpb   protocol grpc no-tlsAdd that to the subscription and sensor-path configuration in the commmon router config above and your router config for gRPC dialout without TLS is done.Pipeline.conf# tls = falseYou can use the [gRPCDIalout] input stage in the default pipeline.conf from github.  Just uncomment the 6 lines shown below.$ grep -A25 ~gRPCDialout~ pipeline.conf | grep -v -e '^#' -e '^$'[gRPCDialout] stage = xport_input type = grpc encap = gpb listen = #57500 tls = falseIf you now run pipeline with the debug option, you should see these lines when Pipeline starts and the router (at 172.30.8.53) connects#$ bin/pipeline -config pipeline.conf -log= -debug | grep gRPCINFO[2017-05-08 11#25#50.046573] gRPC starting block                           encap=gpb name=grpcdialout server=#57500 tag=pipeline type=~pipeline is SERVER~INFO[2017-05-08 11#25#50.046902] gRPC# Start accepting dialout sessions        encap=gpb name=grpcdialout server=#57500 tag=pipeline type=~pipeline is SERVER~INFO[2017-05-08 11#26#03.572534] gRPC# Receiving dialout stream                encap=gpb name=grpcdialout peer=~172.30.8.53#61857~ server=#57500 tag=pipeline type=~pipeline is SERVER~And that’s it.  You’re done.  Telemetry data is streaming into pipeline and you can do with it what you want.  You can stop reading now unless you want to experiment with TLS.gRPC Dialout With TLSIn a dialout scenario, the router is the “client” and Pipeline is the “server.”  Therefore, in the TLS handshake, Pipeline will need to send a certificate to authenticate itself to the router.  The router validates Pipeline’s certificate using the public certificate of the Root Certificate Authority (CA) that signed it and then generates sesssion keys to encrypt the session.To make this all work, you need the following#1. A Root CA certificate2. A Pipeline certificate signed by the Root CA3. A copy of the Root CA certificate on the routerFor the purpose of this tutorial, I will use openssl (an open-source TLS toolkit) for the root CA and Pipeline certificate.  If your organization has an existing PKI, you can skip the first two steps and just copy the Root CA certificate to the router.Certificates for TLS Dialout1. The rootCA Key and CertificateFor simplicity, I’ll generate the rootCA on the same server that I am running Pipeline.  First, create a rootCA key-pair (may require sudo)#scadora@darcy#/etc/ssl/certs$ openssl genrsa -out rootCA.key 2048Generating RSA private key, 2048 bit long modulus...........+++................................+++e is 65537 (0x10001)scadora@darcy#/etc/ssl/certs$Now use that key to self-sign the rootCA certificate.  It will ask you a bunch of questions that you can fill out as you want (I just used all defaults)#scadora@darcy#/etc/ssl/certs$ sudo openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -extensions v3_ca -config ../openssl.cnf -out rootCA.pem You are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]#State or Province Name (full name) [Some-State]#Locality Name (eg, city) []#Organization Name (eg, company) [Internet Widgits Pty Ltd]#Organizational Unit Name (eg, section) []#Common Name (e.g. server FQDN or YOUR name) []#Email Address []#scadora@darcy#/etc/ssl/certs$You should now have a rootCA certificate called rootCA.pem.2. The Pipeline CertificateFirst, create a key pair for Pipeline.  In this case, I’ve called it “darcy.key” since darcy is the name of the server on which I am running Pipeline.scadora@darcy#/etc/ssl/certs$  sudo openssl genrsa -out darcy.key 2048Generating RSA private key, 2048 bit long modulus................+++..+++e is 65537 (0x10001)scadora@darcy#/etc/ssl/certs$Next, create a Certificate Signing Request (CSR) using the key you just generated.  In the following, I use all the defaults except for the Common Name, which I set as darcy.cisco.com#scadora@darcy#/etc/ssl/certs$ openssl req -new -key darcy.key -out darcy.csrYou are about to be asked to enter information that will be incorporatedinto your certificate request.What you are about to enter is what is called a Distinguished Name or a DN.There are quite a few fields but you can leave some blankFor some fields there will be a default value,If you enter '.', the field will be left blank.-----Country Name (2 letter code) [AU]#State or Province Name (full name) [Some-State]#Locality Name (eg, city) []#Organization Name (eg, company) [Internet Widgits Pty Ltd]#Organizational Unit Name (eg, section) []#Common Name (e.g. server FQDN or YOUR name) []#darcy.cisco.exampleEmail Address []#Please enter the following 'extra' attributesto be sent with your certificate requestA challenge password []#An optional company name []#scadora@darcy#/etc/ssl/certs$Finally, use your rootCA certificate to sign the CSR (“darcy.csr”) you just generated and create a certificate for Pipeline (“darcy.pem”)#scadora@darcy#/etc/ssl/certs$ openssl x509 -req -in darcy.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out darcy.pem -days 500 -sha256Signature oksubject=/C=AU/ST=Some-State/O=Internet Widgits Pty Ltd/CN=darcy.cisco.exampleGetting CA Private Keyscadora@darcy#/etc/ssl/certs$Note# Some people issue certificates with a Common Name set to the IP address of the server instead of a FQDN.  Should you do this for the Pipeline certificate, bear in mind that the certificate will also need to have a Subject Alternative Name section that explicitly lists all valid IP addresses.  If you see the following message in your grpc trace, this could be your problem.RP/0/RP0/CPU0#SunC#show grpc trace emsTue May 16 19#35#44.792 UTC3 wrapping entries (141632 possible, 320 allocated, 0 filtered, 3 total)May 16 19#35#40.240 ems/grpc 0/RP0/CPU0 t26842 EMS-GRPC# grpc# Conn.resetTransport failed to create client transport# connection error# desc = ~transport# x509# cannot validate certificate for 172.30.8.4 because it doesn't contain any IP SANs~For more info on certificates with IP Addresses, take a look at this discussion.3. Copy rootCA Certificate to the routerFor the router to validate Pipeline’s certificate, it needs to have a copy of the rootCA certificate in /misc/config/grpc/dialout/dialout.pem (the filename is important!).  Here is how to scp the rootCA.pem to the appropriate file and directory#RP/0/RP0/CPU0#SunC#bashTue May 16 18#06#04.592 UTC[xr-vm_node0_RP0_CPU0#~]$ scp scadora@172.30.8.4#//etc/ssl/certs/rootCA.pem /misc/config/grpc/dialout/dialout.pemrootCA.pem                                    100% 1204     1.2KB/s   00#00[xr-vm_node0_RP0_CPU0#~]$Configuring the Router for gRPC Dialout with TLSIn addition to the common sensor-group and subscription configuration that we configured on the router at the beginning of the Dialout section, we also need a destination-group. TLS is the default for MDT for gRPC, so the destination-group config just looks like this#telemetry model-driven destination-group DGroup2  address family ipv4 172.30.8.4 port 57500   encoding self-describing-gpb   protocol grpc Configuring Pipeline for tls=trueWe can use the [gRPCDIalout] input stage in the default pipeline.conf.  The only change is the last 4 lines where we enable tls and set the pem, key and servername to the values corresponding to the Pipeline certificate we generated earlier.scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ grep -A30 ~gRPCDialout~ pipeline.conf | grep -v -e '^#' -e '^$'[gRPCDialout] stage = xport_input type = grpc encap = gpb listen = #57500 tls = true tls_pem = /etc/ssl/certs/darcy.pem tls_key = /etc/ssl/certs/darcy.key tls_servername = darcy.cisco.exampleAnd that’s it.  Run pipeline as usual and you’ll see the router connect#scadora@darcy#~/bigmuddy-network-telemetry-pipeline$ sudo bin/pipeline -config pipeline.conf -log= -debug | grep gRPCINFO[2017-05-16 13#00#40.976896] gRPC starting block                           encap=gpb name=grpcdialout server=#57500 tag=pipeline type=~pipeline is SERVER~INFO[2017-05-16 13#00#40.977505] gRPC# Start accepting dialout sessions        encap=gpb name=grpcdialout server=#57500 tag=pipeline type=~pipeline is SERVER~INFO[2017-05-16 13#01#09.775514] gRPC# Receiving dialout stream                encap=gpb name=grpcdialout peer=~172.30.8.53#59865~ server=#57500 tag=pipeline type=~pipeline is SERVER~On the router, the grpc trace will show you the server name (darcy.cisco.example) of the received certificate.RP/0/RP0/CPU0#SunC#show grpc trace emsTue May 16 20#01#15.059 UTC2 wrapping entries (141632 possible, 320 allocated, 0 filtered, 2 total)May 16 20#01#06.757 ems/conf 0/RP0/CPU0 t26859 EMS-CONF#emsd_is_active_role get proc role (1)May 16 20#01#06.759 ems/info 0/RP0/CPU0 t26843 EMS_INFO# nsDialerCheckAddTLSOption#322 mdtDialout# TLS pem# /misc/config/grpc/dialout/dialout.pem, Server host# darcy.cisco.exampleRP/0/RP0/CPU0#SunC#That’s it.  You’re done with gRPC Dialout with TLS.  No need to read further.gRPC DialinIn a dialin scenario, Pipeline sends the TCP SYN packet and acts as the “client” in the gRPC session and TLS handshake (if you’re configuring TLS).Common Router Config for gRPC DialInFor this part of the tutorial, I’ll re-use the MDT router config from the gRPC dialin example  It should look like this#grpc port 57500!telemetry model-driven sensor-group SGroup3  sensor-path openconfig-interfaces#interfaces/interface ! subscription Sub3  sensor-group-id SGroup3 sample-interval 30000Note that there is no destination-group for dialin.Common Dialin CredentialsRegardless of whether you use TLS or not, Pipeline will have to provide a username and password when it first connects to the router.On the router side, you need to configure a username and password that Pipeline can use when it dials in.  If you’re just doing a quick test in the lab, assign the user to one of these default usergroups# sysadmin, netadmin, or root-lr.  For example#username mdt group sysadmin secret 5 $1$kAbv$xNk9KA.mIC7K2wfdpGjzk1If you want to be more restrictive, here is the minimal taskgroup that you will need to support telemetry for gRPC dialin#taskgroup mdt-grpc task read li task read acl task read cdp task read eem task read boot task read diag task read ipv4 task read ipv6 task read snmp task read vpdn task read crypto task read system task read logging task read fault-mgr task read interface task read ext-access task read filesystem task read tty-access task read config-mgmt task read ip-services task read host-services task read basic-services task read config-services!usergroup mdt-grpc taskgroup mdt-grpc!username mdt group mdt-grpc secret 5 $1$kAbv$xNk9KA.mIC7K2wfdpGjzk1Next, you get to decide if you want to use TLS or not.gRPC Dialin Without TLSIf you don’t use TLS, your MDT data won’t be encrypted.  On the other hand, there’s less fiddling with certificates. So if you’re trying to get gRPC dialin to work for the first time, this might be a good starting place. There’s nothing you need to add to the router config for this beyond the common router config and credentials we did above. You just need to configure and run Pipeline as shown below.You can use the [mymdtrouter] input stage in the default pipeline.conf.  Just uncomment the 8 lines shown below, changing the server line to match your router’s IP address and configured gRPC port#$ grep -A48 ~mymdtrouter~ pipeline.conf | grep -v -e '^#' -e '^$' [mymdtrouter] stage = xport_input type = grpc encoding = gpbkv encap = gpb server = 172.30.8.53#57500 subscriptions = Sub3 tls = falseNote that the subscription is “Sub3”, which matches the subscription in the router configuration above.  Pipeline will request the pre-configured subscription from the router when it connects.When you run pipeline, you will be prompted for a username and password.  This is the username and password that you configured on the router above.$ bin/pipeline -config pipeline.confStartup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]CRYPT Client [mymdtrouter],[172.30.8.53#57500] Enter username# mdt Enter password#Wait for ^C to shutdownIf you don’t want to have to manually enter the username and password each time you run Pipeline, check out the section below on secure password storage in pipeline.To verify that the connection is established, check that the subscription Destination Group State is Active. Also note that the Destination Group Id has been dynamically created (since we don’t configure a destination-group on the router for dialin) and begins with “DialIn_.”RP/0/RP0/CPU0#SunC#show telemetry model sub Sub3Thu May 18 20#46#38.658 UTCSubscription#  Sub3-------------  State#       ACTIVE  Sensor groups#  Id# SGroup3    Sample Interval#      30000 ms    Sensor Path#          openconfig-interfaces#interfaces/interface    Sensor Path State#    Resolved  Destination Groups#  Group Id# DialIn_1019    Destination IP#       172.30.8.4    Destination Port#     48667    Encoding#             self-describing-gpb    Transport#            dialin    State#                Active    No TLS    Total bytes sent#     5723    Total packets sent#   4    Last Sent time#       2017-05-18 20#46#28.2143492698 +0000That’s it, you’re done.  No need to read the next section unless you want to do TLS.gRPC Dialin With TLSIn a dialin scenario, Pipeline acts as the “client” in the TLS handshake.  Therefore, the router will need to send a certificate to authenticate itself to Pipeline.There are a couple ways to go about creating the router certificate. If you already have a root CA, you can issue a certificate for the router.  However, because this tutorial is far too long already, I’m going to take the easy way out and use a self-signed certificate.Router Certificate and Config for gRPC TLS DialInThe first thing we have to do is enable the gRPC service on the router for TLS by adding “tls” to the grpc config on the router#grpc port 57500 tlsOnce you do this, the router automatically generates a self-signed cert called “ems.pem”#RP/0/RP0/CPU0#SunC#bashThu May 18 23#05#51.266 UTC[xr-vm_node0_RP0_CPU0#~]$cd /misc/config/grpc[xr-vm_node0_RP0_CPU0#/misc/config/grpc]$lsdialout  ems.key  ems.pem[xr-vm_node0_RP0_CPU0#/misc/config/grpc]$You can use standard openssl commands to view the cert#[xr-vm_node0_RP0_CPU0#/misc/config/grpc]$openssl x509 -noout -text -in ems.pemCertificate#    Data#        Version# 3 (0x2)        Serial Number# 1789 (0x6fd)    Signature Algorithm# sha512WithRSAEncryption        Issuer# C=US, ST=CA, L=San Jose/street=3700 Cisco Way/postalCode=95134, O=Cisco Systems, Inc., OU=CSG, CN=ems.cisco.com/serialNumber=949DF85F746        Validity            Not Before# May 18 22#49#51 2017 GMT            Not After # May 18 22#49#51 2037 GMT        Subject# C=US, ST=CA, L=San Jose/street=3700 Cisco Way/postalCode=95134, O=Cisco Systems, Inc., OU=CSG, CN=ems.cisco.com/serialNumber=949DF85F746        Subject Public Key Info#            Public Key Algorithm# rsaEncryption                Public-Key# (2048 bit)                Modulus#                    00#cf#89#9e#7a#14#5f#6a#f4#8a#75#ce#69#07#00#                    38#2d#5d#1f#71#f5#cb#69#37#3b#6d#9b#20#ab#47#                    9e#2b#b6#4b#be#30#1e#54#81#76#4f#61#91#de#4e#                    47#80#b2#6d#0c#f3#2a#69#be#85#67#ca#a3#80#7f#                    bc#40#2e#63#5d#c9#ec#a4#fc#60#ae#b2#10#2a#f9#                    de#02#11#50#5a#1e#43#c9#3a#95#6b#9f#fa#3d#f4#                    db#1f#a9#6d#bd#7b#0b#d8#87#64#08#26#2b#54#82#                    42#2f#a2#7e#36#64#9b#42#9a#ff#bf#19#25#2f#42#                    3e#9d#94#af#fc#ea#62#ef#ec#57#20#57#d9#39#c5#                    bd#77#5c#a9#01#76#e1#2c#69#67#6f#b7#30#f8#f8#                    2c#d1#2c#25#de#66#46#fb#49#30#a7#c9#9c#14#b0#                    70#f4#3f#b2#62#8c#5c#c6#8f#a2#e3#de#75#c3#c3#                    e5#72#1f#4e#40#d4#bd#1b#2a#27#19#e7#80#b3#c9#                    cb#56#4e#5c#99#42#d6#97#23#04#6d#9c#9e#f0#d2#                    0e#8b#5c#02#09#d1#c8#31#04#23#b4#f1#b4#41#a2#                    44#b5#16#fd#c3#80#a5#3d#39#26#de#94#2b#db#22#                    d0#0b#07#92#2d#6a#24#37#d4#db#b2#29#23#f3#00#                    88#13                Exponent# 65537 (0x10001)        X509v3 extensions#            X509v3 Basic Constraints# critical            CA#TRUE            X509v3 Subject Key Identifier#                1C#B6#98#EF#7F#A4#1D#07#0B#6F#73#01#08#E6#0C#8C#97#AC#E0#A2            X509v3 Authority Key Identifier#                keyid#1C#B6#98#EF#7F#A4#1D#07#0B#6F#73#01#08#E6#0C#8C#97#AC#E0#A2    Signature Algorithm# sha512WithRSAEncryption         60#97#b9#e2#cb#d5#1d#b0#48#d5#68#fa#aa#a6#36#de#e3#64#         1f#6a#7f#4b#3e#9c#42#e8#59#23#26#14#c1#b1#0e#f3#17#d5#         34#71#4c#79#6f#f7#62#94#21#a2#d7#d4#99#cc#9c#f2#29#2a#         38#79#19#83#fd#a9#16#df#0e#35#55#5e#11#b5#b7#3f#e6#10#         0d#71#c7#3d#2d#9b#41#44#09#9b#b3#98#64#ab#9e#33#f3#08#         a9#f0#6b#62#93#18#7e#ff#14#a7#ea#c2#c3#3b#ed#a6#b3#69#         25#07#04#41#23#82#c6#12#23#6d#e0#14#80#7c#10#dd#ea#06#         8e#e6#78#f5#42#a0#3e#21#81#7d#48#29#18#29#0a#ef#ce#a1#         7c#38#7b#e8#17#44#db#24#37#ba#1c#53#6d#9d#6f#d2#5c#2a#         69#b5#11#13#4d#7c#cc#3d#44#d2#96#fa#71#41#3a#b6#ab#6e#         e7#b1#ff#53#db#e8#95#5c#67#68#51#80#ab#24#e0#7e#8e#fe#         e1#af#36#8c#bc#b2#3a#69#3f#33#bc#b6#36#25#ad#78#49#d1#         2e#43#6f#f8#80#c3#1c#21#89#cd#da#9f#3d#62#ec#79#1b#b0#         77#0d#96#c8#c8#26#25#0b#94#ae#21#14#d1#1b#e0#f7#11#af#         61#ce#13#74[xr-vm_node0_RP0_CPU0#/misc/config/grpc]$As you can see, this certificate has been issued for a CN=ems.cisco.com and is a CA certificate.Since this is also the CA cert (it’s self-signed), we’ll transfer it to the server running Pipeline.[xr-vm_node0_RP0_CPU0#/misc/config/grpc]$ scp ems.pem scadora@172.30.8.4#scadora@172.30.8.4's password#ems.pem                                       100% 1513     1.5KB/s   00#00    [xr-vm_node0_RP0_CPU0#/misc/config/grpc]$Pipeline for gRPC Dialin with TLSAll that’s left is to configure pipeline.conf for TLS.You can use the [mymdtrouter] input stage in the default pipeline.conf.  Uncomment the 10 lines shown below and do the following#  change the server line to match your router’s IP address and configured gRPC port.  set tls to “true”  set tls_pem to the full path and filename of the ems.pem file you copied from the router above.  set tls_pem to the CN of the router’s certificate (“ems.cisco.com”)$ grep -A48 ~mymdtrouter~ pipeline.conf | grep -v -e '^#' -e '^$'[mymdtrouter] stage = xport_input type = grpc encoding = gpbkv encap = gpb server = 172.30.8.53#57500 subscriptions = Sub3 tls = true tls_pem = /home/scadora/ems.pem tls_servername = ems.cisco.comNote that the subscription is “Sub3”, which matches the subscription in the router configuration above.  Pipeline will request the pre-configured subscription from the router when it connects.When you run pipeline, you will be prompted for a username and password.  This is the username and password that you configured on the router above.$ bin/pipeline -config pipeline.confStartup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]CRYPT Client [mymdtrouter],[172.30.8.53#57500] Enter username# mdt Enter password#Wait for ^C to shutdownIf you don’t want to have to manually enter the username and password each time you run Pipeline, check out the section below on secure password storage in pipeline.To verify that the connection is established, check that the subscription Destination Group State is Active. Also note that the Destination Group Id has been dynamically created (since we don’t configure a destination-group on the router for dialin) and beings with “DialIn_.”RP/0/RP0/CPU0#SunC#show telemetry model-driven subscription Sub3Fri May 19 16#48#22.396 UTCSubscription#  Sub3-------------  State#       ACTIVE  Sensor groups#  Id# SGroup3    Sample Interval#      30000 ms    Sensor Path#          openconfig-interfaces#interfaces/interface    Sensor Path State#    Resolved  Destination Groups#  Group Id# DialIn_1030    Destination IP#       172.30.8.4    Destination Port#     57590    Encoding#             self-describing-gpb    Transport#            dialin    State#                Active    No TLS    Total bytes sent#     11446    Total packets sent#   8    Last Sent time#       2017-05-19 16#48#12.1233215666 +0000That’s it, you’re done.  Have fun with your telemetry data!Appendix# Secure Password Storage for DialinBecause Pipeline cares about your security, it won’t let you store unencrypted router passwords in pipeline.conf.  If you dislike being prompted for a password every time you run it or you want to run pipeline in the background, you can have pipeline encrypt the password using the -pem option and store it in a new file as follows#$ bin/pipeline -config pipeline.conf -pem ~/.ssh/id_rsaStartup pipelineLoad config from [pipeline.conf], logging in [pipeline.log]CRYPT Client [mymdtrouter],[172.30.8.53#57500] Enter username# mdt Enter password#Generating sample config...A new configuration file [pipeline.conf_REWRITTEN] has been written including user name and encrypted password.In future, you can run pipeline non-interactively.Do remember to run pipeline with '-pem /home/scadora/.ssh/id_rsa -config pipeline.conf_REWRITTEN' options.Wait for ^C to shutdownIf you take a look at the [mymdtrouter] stage in pipeline.conf_REWRITTEN, you’ll see that the username and encrypted password are included#$ grep -A10 ~mymdtrouter~ pipeline.conf_REWRITTEN | grep -v -e '^#' -e '^$'[mymdtrouter]subscriptions=Sub3password=PZbS/IG4O+2lsok3xxBjQZwJ5CFyraixl//qdNy67IRMM1YMLlWqbbGHUXVGM1pX0HfKf7JU1beRivkOcwyANPff4hVmF5b7Ne1SBxnKS4VqSU+AMCN/e+FFHFrCA24m0ywTYB/Dt2PJZaUCQmYzxTwa71+Vxc7lHe2dtovH/DGutQfvRa2On6aHeqiQfMbBcEeKqwya4jtmexS11Dt1ai1QXqWgn2WiggvWTGcldANO4Nfkl4vICguVlrVEfNv16qNoPB/HerTNCuGLlBR0EBhxGPxCJteexAxadt68whG4UP/teTiD2qFZ2UFXCRnpnPvpic9LIZIaF4PgNg9AGw==server=172.30.8.53#57500type=grpcencoding=gpbkvencap=gpbtls=falseusername=mdtstage=xport_inputNow you can run pipeline with the rewritten .conf file and it won’t prompt you for the username again#$ sudo bin/pipeline -config pipeline.conf_REWRITTEN -pem ~/.ssh/id_rsaStartup pipelineLoad config from [pipeline.conf_REWRITTEN], logging in [pipeline.log]Wait for ^C to shutdown",
      "url": "/tutorials/2017-05-08-pipeline-with-grpc/",
      "author": "Shelly Cadora",
      "tags": "iosxr, telemetry, gRPC, MDT, pipeline"
    }
    
    
  
  ,
  "#": {}
}
